################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved. 
# This program and the accompanying materials are made available under 
# the terms of the JPOX License v1.0 which accompanies this distribution.
#
# Resources for org.jpox.store.rdbms package
# Version : $Revision: 1.101.2.1 $
################################################################################

JDBC.Statement.ExecutionTime=Execution Time = {0} ms

RDBMS.Connection.SQL.UnallowedOperation=The operation "{0}" is not allowed.

#
# Connection
#
Connection.InvalidCall=Not valid to call method "{0}" on a data store connection obtained from the PersistenceManager.
Connection.NotAvailable=JDOConnection is no longer available

#
# Exceptions
#
RDBMS.Exception = Exception : {0}
RDBMS.Exception.DuplicateColumnName=Duplicate column name "{0}" defined for table "{1}". You cannot map multiple fields to the same column. The duplicated columns are specified by {2} and {3}.
RDBMS.Exception.DuplicateColumnNameUnknownSource=? datastore-identity|index columns|other non mapped to any field ?
RDBMS.Exception.IncompatibleDataType=Incompatible data type for column {0} : was {1} (datastore), but type expected was {2} (metadata). Please check that the type in the datastore and the type specified in the MetaData are consistent.
RDBMS.Exception.MissingColumn=Required columns missing from table "{0}" : {1}. Perhaps your MetaData is incorrect, or you haven't enabled "org.jpox.autoCreateColumns".
RDBMS.Exception.MissingTable=Required table missing : "{2}" in Catalog "{0}" Schema "{1}". JPOX requires this table to perform its persistence operations. Either your MetaData is incorrect, or you need to enable "org.jpox.autoCreateTables"
RDBMS.Exception.NotATable=Table "{0}" is of wrong type {1}. Should be a table
RDBMS.Exception.NotAView=Table "{0}" is of wrong type {1}. Should be a view
RDBMS.Exception.PrimaryKeyColumnNotAllowed=Cannot define a primary key column in a view : {0}, column={1}
RDBMS.Exception.TooManyForeignKeys=Exceeded maximum of {0} foreign keys for table {1}
RDBMS.Exception.TooManyIndices=Exceeded maximum of {0} index keys for table {1}
RDBMS.Exception.ViewDefinition=Invalid view definition for {0} : {1}
RDBMS.Exception.WrongPrecision=Wrong precision for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition).
RDBMS.Exception.WrongPrimaryKey=Expected primary key for table {0} {1} not found in existing keys {2}
RDBMS.Exception.WrongScale=Wrong scale for column {0} : was {1} (according to the JDBC driver) but should be {2} (based on the MetaData definition).
RDBMS.Exception.PersistentSuperclassNotAllowed=Classes backed by views cannot have persistence-capable superclasses : {0}
RDBMS.Exception.UnexpectedColumn=Unexpected column {0} encountered in table {1} schema {2} catalog {3}
RDBMS.Exception.IsNullable=Column {0} should not allow nulls but does. You can prevent nulls by specifying "allows-null" as "false" for the <field> in the MetaData

#
# SchemaAutoStarter
#
RDBMS.SchemaAutoStarter.ClassesReadError=Failed to retrieve classes from SchemaTable : {0}
RDBMS.SchemaAutoStarter.ValidationError=Failed to validate SchemaTable for Schema "{0}". Either it doesn't exist, or doesn't validate : {1}
RDBMS.SchemaAutoStarter.DropAndCreate=Dropping Schema Table "{0}" and recreating as new
RDBMS.SchemaAutoStarter.AddClassError=Error adding class {0} to list of persistence-managed classes : {1}
RDBMS.SchemaAutoStarter.DeleteClass=Deleting class {0} from list of persistence-managed classes
RDBMS.SchemaAutoStarter.DeleteClassError=Error deleting class {0} from list of persistence-managed classes : {1}
RDBMS.SchemaAutoStarter.DeleteClassesError=Error deleting all persistence-managed classes from supported list : {1}
RDBMS.SchemaAutoStarter.StorageDescription=Class names and associated table names are stored in the datastore in a table "{0}"
RDBMS.SchemaAutoStarter.AssertIsOpen=Unable to use the SchemaAutoStarter since it is not open!
RDBMS.SchemaAutoStarter.AssertIsClosed=Unable to open the SchemaAutoStarter since it is already open!
RDBMS.SchemaAutoStarter.DatastoreInitialisationException=Unknown error in datastore : {0}

#
# RDBMS Manager
#
RDBMS.Manager.DefaultCatalogNameUnusable=Default Catalog name "{0}" has been specified yet the Database Adapter (JDBC driver) doesn't support specification of catalog name in table definitions !
RDBMS.Manager.DefaultSchemaNameUnusable=Default Schema name "{0}" has been specified yet the Database Adapter (JDBC driver) doesn't support specification of schema name in table definitions !

RDBMS.Manager.DatabaseInitialisationError=Failed initialising database.
RDBMS.Manager.DatabaseConnectionError=Error obtaining connection to database. : {1}
RDBMS.Manager.DatabaseInitialisationAdvice=Please check that your database JDBC driver is accessible, and the database URL and username/password are correct.

RDBMS.Manager.SchemaDataInitialise=Initialising Catalog "{0}", Schema "{1}" using "{2}" auto-start option
RDBMS.Manager.SchemaDataInitialised=Catalog "{0}", Schema "{1}" initialised - managing {2} classes
RDBMS.Manager.SchemaDataInitialisedReadOnly=Catalog "{0}", Schema "{1}" initialised - managing {2} classes [READONLY]
RDBMS.Manager.SchemaDataInitialisedFixed=Catalog "{0}", Schema "{1}" initialised - managing {2} classes [FIXED]
RDBMS.Manager.SchemaDataUninitialisedForSchema=Schema Data has not been initialised for Catalog "{0}", Schema "{1}"

RDBMS.Manager.AddSchemaData=Managing Persistence of {0}
RDBMS.Manager.UnableToFindSuperclassTable=Class "{0}" has been specified to use an inheritance strategy of "superclass-table", yet the table for a superclass cannot be found!
RDBMS.Manager.NoTableForEmebeddedClass=Class "{0}" has been specified as "embedded-only", and so it can only exist within the tables of other classes. No table will be created.

RDBMS.Manager.TableAlreadyInUse=The class specified ({0}) has a default table name of {1}, but this is in use by a different class ({2}). JPOX will use a separate instance of this table internally and data will be persisted to the same datastore table. It is your responsibility to make sure that both of these classes are compatible for saving to the same place.

RDBMS.Manager.JoinTableCreationError=Join Tables can only be created as a side effect of adding a new class

RDBMS.Manager.PersistentClassNotFound=Persistent Class not found for id "{0}"
RDBMS.Manager.ObjectWithIdNotFound=Object with id "{0}" not found !
RDBMS.Manager.NewObjectAIDInvalidClassError=Attempt to find new application-identity for class ({0}) that does not use "application identity".
RDBMS.Manager.NewObjectAIDInvalidFieldType=Attempt to find new application-identity for class {0} yet field {1} has invalid type ({2}). Should be int/long/Integer/Long.

RDBMS.Manager.ObjectIdClassDuplicated=Class {0} has been defined with objectid-class {1}, yet this is already used by a different inheritance tree (e.g by class {2}). Please correct this so that each inheritance tree uses their own objectid-class.
RDBMS.Manager.IDAssignedToIncorrectClass=Id {0} is assigned to class {1}, but it's not the correct object-id type for this class.

RDBMS.Manager.ObtainingNextIDForClass=Obtaining next ID for class {0}
RDBMS.Manager.POIDConnectionOpenError=Error while obtaining connection for POID generation : {0}
RDBMS.Manager.POIDConnectionCloseError=Error while closing connection for POID generation : {0}
RDBMS.Manager.StrategyValueGenerated=Generated value for field "{0}" using strategy="{1}" (PoidGenerator="{2}") : value={3}

RDBMS.Manager.ColumnInfoLoaded=Column info loaded for Catalog "{0}", Schema "{1}", {2} tables, time = {3} ms
RDBMS.Manager.ColumnInfoNotFoundForTable=No column info found for table "{0}" - the table apparently doesnt yet exist in the datastore
RDBMS.Manager.ColumnInfoNotFound=No column info found for column "{0}" of table "{1}"
RDBMS.Manager.ColumnInfos=Column info retrieved for table "{0}" : {1} columns found
RDBMS.Manager.ColumnInfo=Column info retrieved for column "{0}" of table "{1}"
RDBMS.Manager.TableIDColumnError=Table for class {0} has no ID column
RDBMS.Manager.FieldTableError=Field {0}.{1} has no table of its own in which to look for {2}
RDBMS.Manager.InvalidPseudoFieldNameForSet=Invalid pseudo-field name {0} in macro {1}, must be "owner" or "element"
RDBMS.Manager.InvalidPseudoFieldNameForMap=Invalid pseudo-field name {0} in macro {1}, must be "owner", "key" or "value"

RDBMS.Manager.AddClassesToSchema=Add classes to Catalog "{0}", Schema "{1}"
RDBMS.Manager.AddClassesError=Add classes transaction is not active
RDBMS.Manager.AddTablesRollback=An error occurred while auto-creating schema elements - rolling back
RDBMS.Manager.AddTablesRollbackError=An error occurred while auto-creating schema elements. The following exception occurred while attempting to rollback the partially-completed schema changes : {0}
RDBMS.Manager.AddClassesInvalidClassError=Referenced class/interface {0} is not persistence-capable !
RDBMS.Manager.AutoCreateError=Error(s) were found while auto-creating/validating the datastore for classes. The errors are printed in the log, and are attached to this exception.
RDBMS.Manager.AddClassesExceptionError=An exception was thrown while adding/validating class(es) : {0}
RDBMS.Manager.RemoveAllClassesFromSchema=Removing all classes from persistence management for Catalog "{0}", Schema "{0}"
RDBMS.Manager.RemoveClass=Removing class "{0}" from persistence management
RDBMS.Manager.RemoveClassesExceptionError=An exception was thrown while dropping class(es) : {0}

RDBMS.Manager.InvalidGeneratedId=Invalid Id generated for field {0}, id : {1}

RDBMS.Manager.NonPersistenceCapableCollectionElementNeedsJoin=No <join> metadata found for field {0} with non PersistenceCapable elements/values. This metadata {1} needs adding the join. 

RDBMS.Manager.MapWithoutJoinWithoutMappedBy=Field "{0}" is a map that has been specified without a join table and neither the key nor the value has a mapped-by specified. This is invalid!

RDBMS.Manager.InvalidArgumentForQuery=Invalid query argument {0} : should be a String containing a filter for the query, or an existing Query to use as a basis.

#
# RDBMS Adapter
#
RDBMS.Adapter.NoAdapterFound=No Database Adapter was found for your JDBC driver specified. Faling back to the generic DatabaseAdapter!
RDBMS.Adapter.AdapterClassNotFound=The Datastore Adapter class "{0}" was not found. If this is a class that was specified by you in initialising the PMF, please try the JPOX auto-detection instead since your class wasnt found.

RDBMS.Adapter.OracleAdapterNotFound=The Oracle adapter was not found
RDBMS.Adapter.MetaDataAccessError=Error accessing database MetaData
RDBMS.Adapter.JDBCTypeNotSupported=JDBC type "{0}" not supported by the JDBC driver. Please check your specification of "jdbc-type" and the driver capabilities.
RDBMS.Adapter.JDBCTypesNotSupported=None of the specified JDBC types are supported
RDBMS.Adapter.SQLTypeDiscardedForJDBCType=SQL type "{0}" (for JDBC type "{1}") was discarded by the database adapter

RDBMS.Adapter.TransactionIsolationUnsupported=Transaction Isolation level {0} is unsupported. Not used.

RDBMS.Adapter.MappingFieldError={0} can only be used with a persistence-capable field
RDBMS.Adapter.MappingConstructorMissing=Missing constructor {0}(ClassBaseTable,int)
RDBMS.Adapter.MappingFieldNotSupported=Fields of type {0} not (yet) supported
RDBMS.Adapter.MappingConstructorError=Can't access constructor for mapping object with class {0}
RDBMS.Adapter.MappingInstantiationError=Can't instantiate mapping object with class {0}
RDBMS.Adapter.MappingConstructorFailure=Constructor for {0} failed

RDBMS.Adapter.CatalogNameError=Don't know how to determine the current catalog name for this type of DBMS : {0} {1}
RDBMS.Adapter.SchemaNameError=Don't know how to determine the current schema name for this type of DBMS : {0} {1}

RDBMS.Adapter.CatalogsInTableDefinitions=Database adapter allows catalogs to be used in table definitions
RDBMS.Adapter.SchemasInTableDefinitions=Database adapter allows schemas to be used in table definitions

RDBMS.Adapter.AutoIncrementNotSupported=This adapter does not support auto-increment keys
RDBMS.Adapter.SequenceNotSupported=This adapter does not support sequences
RDBMS.Adapter.SequenceNameNullNotSupported=This adapter does not support sequences without names

RDBMS.Adapter.JDBC.NoProductNameError=Error : This JDBC driver has no product name. Unable to select the requisite RDBMS adapter.
RDBMS.Adapter.JDBC.ProductNameAccessError=Error : This JDBC driver gave an error when trying to access the product name. Unable to select the requisite RDBMS adapter : {0}
RDBMS.Adapter.InstantiationError=Error : An error occurred trying to instantiate an instance of the adapter "{0}" for this JDBC driver : {1}

RDBMS.Adapter.Derby.InitialisationError=Error initialising derby schema : {0}

#
# Connection
#
RDBMS.Connection.Opened=Connection "{0}" opened with isolation level "{1}"
RDBMS.Connection.Closed=Connection "{0}" closed

#
# TypeInfo
#
TypeInfo.UnrecognizedDatatype=Data type {0} is not recognized by the JDBC. Validation will be ignored

#
# Extent
#
RDBMS.Extent.ClassHasNoPersistentFields=Extent cannot be created because the class "{0}" has no persistent fields.
RDBMS.Extent.MappingInvalidForView=Extent cannot be created because the field mapping "{0}" is unsuitable for a view column, for class "{1}"
RDBMS.Extent.ClassNotFound=Extent cannot be created for "{0}" since it requires the loading of subclass "{1}" and this was not found in the CLASSPATH!.

#
# Column
#
RDBMS.Column.FieldPrecisionInvalid=Column {0} has been specified with precision/scale, yet the column datastore type doesn't allow specification of this
RDBMS.Column.PrecisionError=Invalid precision, column = {0}

#
# Column creation
#
RDBMS.ColumnCreation.FieldShouldBeSubclassTableButIsnt=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
RDBMS.ColumnCreation.DeclaredColumnsError=Field "{0}" is declared type requiring multiple FKs and has had its column(s) specified, however the number of columns specified ({1}) is not the same as the number of possible FKs for this field ({2}).
RDBMS.ColumnCreation.ColumnAddedForSubclassType=Added column for type "{0}" for field "{1}" (field declared as using subclass-table)
RDBMS.ColumnCreation.ColumnAddedForReferenceType=Added column for type "{0}" for field "{1}" (field declared as reference type - interface/Object)
RDBMS.ColumnCreation.ImplementationClassNotFound=Field "{0}" is defined as a reference type (interface or Object) and was specified as being implemented by class "{1}" but this class was not found!
RDBMS.ColumnCreation.ImplementationClassIsInterface=Field "{0}" is defined as a reference type (interface or Object) and was specified as being implemented by class "{1}" but this is an interface!

#
# Request
#
RDBMS.Request.InsertWithNoPrimaryKeyError=Insert attempted for class "{0}" yet no (application identity) field(s) was provided.
RDBMS.Request.OptimisticVersionMismatch=Object with id "{0}" in table {1} has been changed in the datastore since your last read. Datastore record has version "{2}" whereas your transaction is using version "{3}"
RDBMS.Request.OptimisticVersionMissing=Object with id "{0}" in table {1} has been deleted from the datastore since your last read.
RDBMS.Request.InsertOfAutoincrementReturnedNullIdentity=Object was inserted into the datastore table {0} with an "autoassign"/"identity" column, yet the datastore returns null when asked for the value of the identity. This is a bug in your datastore driver. The workaround is to use an alternative datastore/value strategy for the field.

#
# Fetch
#
RDBMS.FetchStatement.MappingsHaveInconsistentNumbersOfFields=A fetch request has a main table with primary key with {0} columns, yet the passed field which will join to it has {1} columns! Please report this as a JPOX bug!

#
# Mappings
#
RDBMS.MappingManager.UnknownSQLTypeForJavaType=SQL type {1} declared for field of java type {0} cant be mapped for this datastore.
RDBMS.MappingManager.UnknownJDBCTypeForJavaType=JDBC type {1} declared for field of java type {0} cant be mapped for this datastore.
RDBMS.MappingManager.UnsupportedJavaType=The java type {0} (jdbc-type="{1}", sql-type="{2}") can't be mapped for this datastore. No mapping is available.
RDBMS.MappingManager.UnknownSQLType=SQL type {1} declared for field {0} cant be mapped for this datastore.
RDBMS.MappingManager.UnknownJDBCType=JDBC type {1} declared for field {0} cant be mapped for this datastore.
RDBMS.MappingManager.UnsupportedType=The java type {1} declared for field {0} can't be mapped for this datastore using the JDBC/SQL type specified. Please either change the JDBC/SQL type specification, or remove it so that the JPOX default can be tried.

RDBMS.Mapping.NoTypeFoundForColumn=No suitable JDBC type found for column "{0}"
RDBMS.Mapping.UnableToSetParam=Cannot set {0} parameter: value = {1} for column "{2}" : {3}
RDBMS.Mapping.UnableToGetParam=Cannot get {0} result for param = {1} for column "{2}" : {3}
RDBMS.Mapping.IllegalNullValueInColumn=Illegal null value in column {0}
RDBMS.Mapping.IllegalValueInColumn=Illegal value {0} in column {1}
RDBMS.Mapping.ObjectNotSerializable=Object of type {0} isn't Serializable
RDBMS.Mapping.IllegalValueForBooleanInColumn=Boolean field stored in "{0}" column had illegal value "{1}" when retrieved from the datastore!
RDBMS.Mapping.DataLongerThanColumn=Attempt to store value "{0}" in column "{1}" that has maximum length of {2}. Please correct your data!

#
# SCO
#
RDBMS.SCO.ArrayMetaDataMissing=The field "{0}" has been declared as being an array, yet there is no <array> MetaData specified!
RDBMS.SCO.CollectionMetaDataMissing=The field "{0}" has been declared as being a collection, yet there is no <collection> MetaData specified!
RDBMS.SCO.MapMetaDataMissing=The field "{0}" has been declared as being a map, yet there is no <map> MetaData specified!
RDBMS.SCO.ElementMetaDataNotFound=The MetaData for the element class "{0}" of the collection field "{1}" was not found.
RDBMS.SCO.ValueMetaDataNotFound=The MetaData for the value class "{0}" of the map field "{1}" was not found.
RDBMS.SCO.IteratorStatementIsNull=Iterator query statement is null !!
RDBMS.SCO.IteratorRequestFailed=Iteration request failed : {0}
RDBMS.SCO.SizeRequestFailed=Size request failed : {0}
RDBMS.SCO.ContainsRequestFailed=Contains request failed : {0}
RDBMS.SCO.AddRequestFailed=Add request failed : {0}
RDBMS.SCO.UpdateEmbeddedKeyFailed=Update embedded key failed : {0}
RDBMS.SCO.UpdateEmbeddedValueFailed=Update embedded value failed : {0}
RDBMS.SCO.RemoveRequestFailed=Remove request failed : {0}
RDBMS.SCO.ClearRequestFailed=Clear request failed : {0}
RDBMS.SCO.GetRequestFailed=Get request failed : {0}
RDBMS.SCO.SetRequestFailed=Set request failed : {0}
RDBMS.SCO.PutRequestFailed=Put request failed : {0}
RDBMS.SCO.IndexofRequestFailed=IndexOf request failed : {0}
RDBMS.SCO.ContainsKeyRequestFailed=ContainsKey request failed : {0}
RDBMS.SCO.ContainsValueRequestFailed=ContainsValue request failed : {0}
RDBMS.SCO.MaxAdapterColumnIdRequestFailed=MaxAdapterColumnId request failed : {0}
RDBMS.SCO.QueryOverCollectionImpossible=Can't query over a Collection of second-class elements.
RDBMS.SCO.QueryOverMapImpossible=Can't query over a Map of second-class elements.
RDBMS.SCO.GetIndicesFailed.InvalidElements=GetIndices failed : One or more elements specified doesn't exist : {0}

RDBMS.SCO.MappedByNonExistent=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesn't exist in the class "{2}".
RDBMS.SCO.MappedByTypeInvalid=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"
RDBMS.SCO.InverseOwnerMappedByFieldInvalidType=The owner field {0} of element class {1} has an incorrect type "{2}". Should be "{3}"
RDBMS.SCO.UpdateFkRequestFailed=Could not update the foreign key using statement : {0}
#
# SCO Collection
#
RDBMS.SCO.Collection.WriteInvalidWithDifferentPM=Can't write element from a different Persistence Manager
RDBMS.SCO.Collection.CannotContainEmbeddedElement=Collection field "{0}" has been specified to contain the element "{1}" unembedded yet this is already identified as being stored embedded in a different field. This is invalid. You can't store the same object embedded and unembedded!

RDBMS.SCO.Collection.InverseOwnerMappedByFieldNotPresent=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
RDBMS.SCO.Collection.InverseOwnerFieldNotPresent=Class "{0}" has collection field "{1}" and this has no mapping in the table for the element class "{2}"

RDBMS.SCO.Collection.ElementWithSubclassTableWithMultipleTablesNotSupported=The field "{0}" is a collection field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. JPOX doesnt currently support this situation.
RDBMS.SCO.Collection.InterfaceElementWithMoreThanOneImplementationNotSupported=Collection has been defined with elements of an interface type "{0}" and there are more than 1 implementation for this interface type found. JPOX doesnt currently support use of interface where there is more than 1 interface implementation.

RDBMS.SCO.Collection.ElementIsInvalid=Class {0} is not a valid element type for this collection (Field "{1}"). Must be "{2}" or subclass

RDBMS.SCO.Collection.ClearElementsFromInverseDeleteDependent=Clear of elements from FK Collection deleted the elements since the field is "dependent"
RDBMS.SCO.Collection.ClearElementsFromInverseDelete=Clear of elements from FK Collection deleted the elements since owner/index columns weren't nullable
RDBMS.SCO.Collection.ClearElementsFromInverseNull=Clear of elements from FK Collection removed the elements while leaving the elements intact.

#
# SCO Set
#
RDBMS.SCO.Set.WriteInvalidWithDifferentPM=Can't write element from a different Persistence Manager
RDBMS.SCO.Set.NullElementsNotAllowed=Null elements not allowed in persistent sets.
RDBMS.SCO.Set.ElementAlreadyExistsinMtoN=Collection field "{0}" was asked to add element "{1}" to the M-N relation but the element already has this field in its collection

#
# SCO List
#
RDBMS.SCO.List.InverseIndexFieldNotPresent=Class "{0}" has collection field "{1}" and this has no mapping in the table for the index of the element class "{2}". Maybe you declared the field as a java.util.Collection and instantiated it as a java.util.List yet omitted the <order> element in the MetaData ?
RDBMS.SCO.List.WriteInvalidWithDifferentPM=Can't write element from a different Persistence Manager
RDBMS.SCO.List.RemoveElementFromInverseDelete=Remove of element from Inverse List deleted the element since owner/index columns weren't nullable
RDBMS.SCO.List.RemoveElementFromInverseNull=Remove of element from Inverse List removed the element from the List while leaving the element intact.
RDBMS.SCO.List.OrderColumnMissing=Field "{0}" has been instantiated as a List using a join table yet the join table has no "ordering" column. Please specify the <order> tag in the MetaData.

#
# SCO Array
#
RDBMS.SCO.Array.ElementWithSubclassTableWithMultipleTablesNotSupported=The field "{0}" is an array field where the elements use "subclass-table" inheritance strategy and where there are more than 1 subclass where the element is persisted. JPOX doesnt currently support this situation.
RDBMS.SCO.Array.InverseOwnerMappedByFieldNotPresent=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}" owner field "{3}"
RDBMS.SCO.Array.InverseOwnerFieldNotPresent=Class "{0}" has array field "{1}" and this has no mapping in the table for the element class "{2}"
RDBMS.SCO.Array.InverseIndexFieldNotPresent=Class "{0}" has array field "{1}" and this has no mapping in the table for the index of the element class "{2}"
RDBMS.SCO.Array.InterfaceElementWithMoreThanOneImplementationNotSupported=Array is of an interface type "{0}" and there are more than 1 implementation for this interface type found. JPOX doesnt currently support use of interface where there is more than 1 interface implementation.

#
# SCO Map
#
RDBMS.SCO.Map.InverseKeyFieldNotSpecified=The Map "{0}" has been specified without a key "mapped-by" field. You must specify a <key mapped-by=...> since the key is a field in the value class.
RDBMS.SCO.Map.InverseKeyFieldTypeIncompatible=The Map "{0}" has been specified with a key type of "{1}" yet the field of the key in the value class is of type "{2}"!
RDBMS.SCO.Map.InverseKeyFieldNotFound=Value class "{0}" has been defined to contain a field "{1}" that represents the key of the map but this field was not found!

RDBMS.SCO.Map.InverseOwnerKeyFieldNotPresent=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}" key field "{3}"
RDBMS.SCO.Map.InverseOwnerValueFieldNotPresent=Class "{0}" has map field "{1}" and this has no mapping in the table for the key class "{2}" value field "{3}"
RDBMS.SCO.Map.InverseOwnerMappedByFieldInvalidType=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
RDBMS.SCO.Map.InverseOwnerFieldNotPresent=Class "{0}" has map field "{1}" and this has no mapping in the table for the value class "{2}"

RDBMS.SCO.Map.InverseValueFieldNotSpecified=The Map "{0}" has been specified without a value "mapped-by" field. You must specify a <value mapped-by=...> since the value is a field in the key class.
RDBMS.SCO.Map.InverseValueFieldTypeIncompatible=The Map "{0}" has been specified with a value type of "{1}" yet the field of the value in the key class is of type "{2}"!
RDBMS.SCO.Map.InverseValueFieldNotFound=Key class "{0}" has been defined to contain a field "{1}" that represents the value of the map but this field was not found!

RDBMS.SCO.Map.WriteKeyInvalidWithDifferentPM=Can't write key from a different Persistence Manager
RDBMS.SCO.Map.WriteValueInvalidWithDifferentPM=Can't write value from a different Persistence Manager
RDBMS.SCO.Map.NullKeysNotAllowed=Null keys not allowed in persistent maps.
RDBMS.SCO.Map.NullValuesNotAllowed=Null values not allowed in persistent maps.
RDBMS.SCO.Map.KeyIsInvalid=Class {0} is not a valid key type for this Map. Must be {1}
RDBMS.SCO.Map.ValueIsInvalid=Class {0} is not a valid value type for this Map. Must be {1}
RDBMS.SCO.Map.InterfaceValueNotSupported=Collection has been specified with an value-type "{0}" which is an interface. JPOX doesnt currently fully support the use of value-types that are interfaces. Please change the element-type to be a class.
RDBMS.SCO.Map.MappedByNonExistent=Field "{0}" has been defined as "mapped-by" the field "{1}" yet this "mapped-by" field doesn't exist in the class "{2}".
RDBMS.SCO.Map.MappedByTypeInvalid=Field "{0}" has been defined as "mapped-by" field "{1}" yet this is of an incorrect type ({2}). The field that is set as the "mapped-by" must be of type "{3}"

RDBMS.SCO.Map.KeyMetaDataNotFound=The MetaData for the key class "{0}" of the map field "{1}" was not found.
RDBMS.SCO.Map.ValueMetaDataNotFound=The MetaData for the value class "{0}" of the map field "{1}" was not found.

RDBMS.SCO.Map.InverseKeyValueMappedNotSpecified=Field "{0}" is a Map formed by a ForeignKey. There is no key/value "mapped-by" specified. You must specify <key mapped-by="..."> if you want to use a Map ForeignKey relation.
RDBMS.SCO.Map.InverseKeyStoredInValueButValueNotPC=Field "{0}" is a Map formed by a ForeignKey where the key is stored in the value object, however the value object is not PersistenceCapable (it is "{1}"). The value must be PersistenceCapable to use this type of relation.
RDBMS.SCO.Map.InverseValueStoredInKeyButKeyNotPC=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the key object is not PersistenceCapable (it is "{1}"). The key must be PersistenceCapable to use this type of relation.
RDBMS.SCO.Map.InverseValueStoredinKeyButKeyNotSupported=Field "{0}" is a Map formed by a ForeignKey where the value is stored in the key object, however the JPOX doesnt currently support this type of relation.

#
# Tables
#
RDBMS.Table.AlreadyInitialisedError=Table object has already been initialised : {0}
RDBMS.Table.UninitialisedError=Table object has not been been initialised : {0}
RDBMS.Table.NotValidatedError=Table has not been validated : {0}

RDBMS.Table.ClassHasNoTableError=Attempt to create table for class {0} which has been specified to use an inheritance strategy of "{1}". This means it should not have its own table.
RDBMS.Table.NondurableIdentityUnsupported=No identity not supported for class {0}
RDBMS.Table.InvalidIdentityType=Invalid identity type for class {0}
RDBMS.Table.InvalidPersistenceModifierForField=Invalid persistence-modifier for field {0}

RDBMS.Table.InvalidMapKeyField=The field "{0}" represents a map with the key stored as a field in the value, yet the field specified ({1}) isnt found in the value class.
RDBMS.Table.InvalidMapValueField=The field "{0}" represents a map with the value stored as a field in the key, yet the field specified ({1}) isnt found in the key class.
RDBMS.Table.MissingMapKeyValueField=The field "{0}" represents a map with no join table. In this case you must specify "mapped-by" on either the key or the value element to specify that either the key is stored in the value class, or that the value is stored in the key class.

RDBMS.Table.FieldToColumnMapping=Field [{0}] -> Column(s) [{1}] using mapping of type "{2}" ({3})

RDBMS.Table.DuplicateMapOwnerField=More than one map has its "mapped-by" attribute set to field "{0}" (for example field "{1}"). This could cause a problem since objects of this class can, as a result, be part of multiple relationships and so functionality like dependent-field may not work reliably.

RDBMS.Table.ClassObjectInfo=Table class={0}, object-class={1}

RDBMS.Table.Array.ElementHasNoMetaData=Class "{0}" has been defined with an array of element "{1}" yet no MetaData is found for this element.

RDBMS.Table.CollectionMetaDataError=No <collection> MetaData found for field {0}
RDBMS.Table.Collection.ElementHasNoMetaData=Class "{0}" has been defined with a Collection containing element "{1}" yet no MetaData is found for this element.

RDBMS.Table.MapMetaDataError=No <map> MetaData found for field {0}
RDBMS.Table.Map.ValueHasNoMetaData=Class "{0}" has been defined with a Map containing value "{1}" yet no MetaData is found for this value.
RDBMS.Table.Map.KeyHasNoMetaData=Class "{0}" has been defined with a Map containing key "{1}" yet no MetaData is found for this key.

RDBMS.Table.AutoIncrementNotSupportedByRDBMS=Class "{0}" has field "{1}" specified as using autoassign/identity, yet the RDBMS in use doesn't support this feature

RDBMS.Table.OrderMappingMappedByFieldNotFound=Field "{0}" has an <order> defined to be persisted into the columns in the element table for element field "{1}". This field is not found in the element class.
RDBMS.Table.OrderMappingFieldInvalid=Field "{0}" has an <order> defined to be persisted into the column of field "{1}". This field is of an invalid type. Must be an int/Integer.

RDBMS.Table.OwnerHasNoTable=Class "{0}" has not got its own table and no subclass tables are found for this class. Creation of schema is impossible!
RDBMS.Table.ManagingClassFields=Table {0} will manage the persistence of the fields for class {1} (inheritance strategy="{2}") 

RDBMS.Table.SchemaNameUndeterminable=Schema Name could not be determined for this datastore
RDBMS.Table.CatalogNameUndeterminable=Catalog Name could not be determined for this datastore
RDBMS.Table.ProbeTableError=Probe table {0} could not be found

RDBMS.Table.Error=Error thrown executing {0} : {1}

RDBMS.Table.Creating=Creating table {0}
RDBMS.Table.Dropping=Dropping table {0}
RDBMS.Table.CreatingColumn=Creating column {0} for table {1}
RDBMS.Table.Validating=Validating table : {0}

RDBMS.Table.MacrosNotAllowedInTableDefinition=Class "{0}" uses an SQL Table, however you are not allowed to use macros (such as "{1}") in the table definition.

RDBMS.Table.NewColumn=Column "{0}" added to internal representation of table.
RDBMS.Table.PrimaryKeyColumnNotMapped=Primary Key column "{0}" for table "{1}" is not mapped.
RDBMS.Table.RelationshipMappedByFieldNotFound=Unable to find the field "{0}" in the class "{1}" with a relationship to the field "{2}"

RDBMS.Table.ApplicationIdentitySequenceTypeInvalid=Application identity sequence (auto-increment) types can only be long, Long, int or Integer, yet {0} specified.
RDBMS.Table.ApplicationIdentitySequenceType2Invalid=Application identity sequence (auto-increment) types can only be long, Long, int, Integer, and String yet {0} specified.

RDBMS.Table.PrimaryKeyVendorExtensionDeprecatedFeature=The primary-key vendor extension is a deprecated feature. Use an application-identity class instead.

RDBMS.Table.PrimaryKeyColumnNotFound=Table "{0}" has been specified with a primary-key to include column "{1}" but this column is not found in the table. Please check your <primary-key> column specification.

RDBMS.Table.KeyTypeMapColumnOverwriteValueTypeMapColumn=The Key Type provided for the Map field {0} uses a column that was already used by the Type Value of the Map field.
RDBMS.Table.ValueTypeMapColumnOverwriteKeyTypeMapColumn=The Value Type provided for the Map field {0} uses a column that was already used by the Type Key of the Map field.

#
# Views
#
RDBMS.View.Validating=Validating view : {0}
RDBMS.View.IdentityTypeNotSupported=Class "{0}" has been defined with an identity-type of "{1}". SQL Views cannot be used with this type. You must use "nondurable".
RDBMS.View.InvalidPersistenceModifierForField=Class "{0}" has been defined with field "{1}" with a persistence-modifier of "{2}". You cannot use this with SQL Views - must be persistent or transactional.
RDBMS.View.OperationNotSupported=Class "{0}" uses an SQL View, however the method "{1}" has just been called. This is not supported for SQL Views.
RDBMS.View.IdentityGenerationNotSupported=Class "{0}" uses an SQL View consequently JPOX doesnt support the generation of new identities for objects of this type.
RDBMS.View.MacrosNotAllowedInViewDefinition=Class "{0}" uses an SQL View, however you are not allowed to use macros (such as "{1}") in the view definition.

#
# Indices
#
RDBMS.Table.Index.Creating=Creating index "{0}" in catalog "{1}" schema "{2}"
RDBMS.Table.Index.ColumnNotFound=Table "{0}" has been specified with an index "{1}" and one of the columns defined ("{2}") is not found.
RDBMS.Table.Index.NoColumnsSpecified=Table "{0}" has been specified with an index "{1}" but has no columns defined
RDBMS.Table.Index.MissingIndexes=Required indexes missing from {0} : {1}
RDBMS.Table.Index.Validated=Validated {0} index(es) for table {1}
RDBMS.Table.Index.FieldNotFound=An index "{0}" has been specified to include field "{1}" but this field was not found.

#
# Foreign Keys
#
RDBMS.Table.ForeignKey.Creating=Creating foreign key constraint : "{0}" in catalog "{1}" schema "{2}"
RDBMS.Table.ForeignKey.MissingForeignKeys=Required foreign keys missing from {0} : {1}
RDBMS.Table.ForeignKey.Dropping=Dropping {0} foreign key(s) for table {1}
RDBMS.Table.ForeignKey.Validated=Validated {0} foreign key(s) for table {1}

#
# Candidate (Unique) Keys
#
RDBMS.Table.CandidateKey.Creating=Creating candidate key "{0}" in catalog "{1}" schema "{2}"
RDBMS.Table.CandidateKey.MissingCandidateKeys=Required candidate keys missing from {0} : {1}
RDBMS.Table.CandidateKey.ColumnNotFound=Table "{0}" has been specified with a unique key "{1}" and one of the columns defined ("{2}") is not found.
RDBMS.Table.CandidateKey.NoColumnsSpecified=Table "{0}" has been specified with a unique key "{1}" but has no columns defined
RDBMS.Table.CandidateKey.Validated=Validated {0} unique key(s) for table {1}
RDBMS.Table.CandidateKey.FieldNotFound=A unique key "{0}" has been specified to include field "{1}" but this field was not found.

#
# SecondaryTable
#
RDBMS.Table.Secondary.PrimaryTableNotSpecified=It is not possible to create a SecondaryTable ({0}) without the primary table that it relates to.

#
# CorrespondentColumnsMapping
#
RDBMS.CorrespondentColumnsMapping.ColumnNumbersMismatch=Columns "{0} " have been defined with {1} columns, yet there are only {2} to map to!
RDBMS.CorrespondentColumnsMapping.ColumnTargetDoesntExist=Columns "{0}" has a column "{1}" which has been defined to map to column "{2}" but this doesn't exist!
RDBMS.CorrespondentColumnsMapping.NoRemainingColumnsToMapTo=Columns "{0}" column number {1} has no remaining columns to map to!
RDBMS.CorrespondentColumnsMapping.ColumnMappedTwice=Columns "{0}" has a column "{1}" that has been mapped twice!

#
# Naming
#
Naming.FileNonExistent=File {0} doesn't exist. Check your path or classpath.
Naming.ErrorReadingFile=Error reading Naming file {0} : {1}
Naming.ResolveEntity=resolveEntity({0}, {1})

#
# FieldManager
#
ParameterSetter.FieldCannotBeNull=Field {0} is null, but is mandatory as it's described in the jdo metadata

#
# Poid Generators
#
SequencePoidGenerator.CantCreateSequence=Couldnt create the sequence {0}
SequencePoidGenerator.CantObtainSequenceId=Couldnt obtain a new sequence (unique id) : {0}

#
# Query Statement
#
QueryStatement.RangeVariableInUse=Range variable {0} already in use in query : {1}
QueryStatement.RangeVariableError=Range variable {0} doesn't exist
QueryStatement.DistinctWithForUpdateNotAllowedForRDBMS=The query required use of DISTINCT, however it was not possible to use the "FOR UPDATE" lock because the RDBMS doesnt support the use of this syntax in one query
QueryStatement.OrderByExpressionInconsistency=The ordering clause should be passed the same number of ordering expressions and ordering directions but was passed {0} expressions and {1} directions!
QueryStatement.SyntaxNotSupportedByDatastore=The datastore in use doesnt support the necessary syntax required for this operation "{0}".

#
# Query Result
#
QueryResult.Closed=Query result has been closed
QueryResult.ReadError=Failed to read the result set : {0}
QueryResult.NoMoreElements=No more elements in query result
QueryResult.NotModifiable=Query result sets are not modifiable
QueryResult.NotSupported=This operation is not supported on Query Results
QueryResult.CloseError=Closing query result failed : {0}

#
# Query ResultExpressions
#
QueryResultExpressions.UnsupportedExpressionInResult=The expression {0} is not supported in results.

#
# SQL
#
SQL.DeletePersistent.NotSupported=Deletion by query is not supported for SQL/JPOXSQL queries.
SQL.StatementNullError=You have specified an empty SQL query. This is invalid.
SQL.StatementNotSelectError=You have specified an SQL statement ("{0}") that doesnt start with SELECT. This is invalid.
SQL.NoSelectionsError=You have specified an SQL statement ("{0}") that has no columns selected. This is invalid.
SQL.CandidateExtentsInapplicableError=Candidate extents not applicable to SQL queries.
SQL.CandidateCollectionsInapplicableError=Candidate collections not applicable to SQL queries.
SQL.ResultInapplicableError=Result is not applicable to SQL queries.
SQL.RangeInapplicableError=Range is not applicable to SQL queries.
SQL.FilterStringsInapplicableError=Filter strings not applicable to SQL queries.
SQL.VariablesInapplicableError=Variables not applicable to SQL queries.
SQL.GroupingNotExplicitError=SQL only supports grouping when set explicitly using a GROUP BY in the SQL text.
SQL.OrderingNotExplicitError=SQL only supports ordering when set explicitly using an ORDER BY in the SQL text.
SQL.Statement.Summary=SQL Query : "{0}"

SQL.Candidate.IdColumnNotSelected=SQL query ("{0}") has been specified with a candidate class "{1}" yet the id column ("{2}") has not been selected. When you specify a candidate class you MUST select the id column(s).
SQL.Candidate.DiscriminatorColumnNotSelected=SQL query ("{0}") has been specified with a candidate class "{1}" yet the discriminator column "{2}" has not been selected. When you specify a candidate class you MUST select the discriminator column.
SQL.Candidate.VersionColumnNotSelected=SQL query ("{0}") has been specified with a candidate class "{1}" yet the version column "{2}" has not been selected. When you specify a candidate class you MUST select the version column.

SQL.ParametersInapplicableError=Parameters are untyped in SQL queries.
SQL.InvalidCandidateClassExtentError=Invalid candidate class "{0}" for SQL. It must not have an extent (use requires-extent="false" in the MetaData).
SQL.InvalidCandidateClassNondurableError=Invalid candidate class "{0}" for SQL. It must use non-durable identity (use identity-type="nondurable" in the MetaData).
SQL.IncorrectNumberOfParametersError=The SQL query requires {0} parameters, yet only {1} have been provided.
SQL.NoSuchFieldInResultClassError=SQL query result class {0} has no such field {1}
SQL.ResultClassesHaveNoTableError=SQL query has invalid macro - result classes have no table {0}
SQL.ResultSetMissingColumnsError=SQL query has columns missing ("{0}") from the result set
SQL.ParameterNotProvidedError=SQL query requires the parameter {0}, yet it hasn't been provided.
SQL.UndeclaredParameterError=SQL query has an undeclared parameter {0} in the SQL
SQL.ExecutionError=Error executing SQL query "{0}".
SQL.ImportInapplicableError=Imports not applicable to SQL queries.
SQL.ResultExtractionError=Error encountered when extracting results for SQL query "{0}"
SQL.ExecuteWithMapParamMinimumError=Use of executeWithMap for SQL queries should have keys starting at 1. This map starts at {0}!!
SQL.ExecuteWithMapParamTypeError=Use of executeWithMap for SQL queries should have all keys of type Integer. This map contains keys of type "{0}"

SQL.ParametersRequiredButNoneSupplied=SQL query "{0}" requires {1} parameters yet none have been supplied
SQL.ParameterAtPositionNotSupplied=SQL query "{0}" requires a parameter at position {1} yet none was supplied in the provided Map

#
# JPOX SQL
#
JPOXSQL.InvalidCandidateClassExtentError=Invalid candidate class "{0}" for JPOXSQL. It must not have an extent (use requires-extent="false" in the MetaData).
JPOXSQL.InvalidCandidateClassNondurableError=Invalid candidate class "{0}" for JPOXSQL. It must use non-durable identity (use identity-type="nondurable" in the MetaData).
JPOXSQL.IncorrectNumberOfParametersError=The JPOXSQL query requires {0} parameters, yet only {1} have been provided.
JPOXSQL.NoSuchFieldInResultClassError=JPOXSQL query result class {0} has no such field {1}
JPOXSQL.ResultClassesHaveNoTableError=JPOXSQL query has invalid macro - result classes have no table {0}
JPOXSQL.ResultSetMissingColumnsError=JPOXSQL query has columns missing ("{0}") from the result set
JPOXSQL.ParameterNotProvidedError=JPOXSQL query requires the parameter {0}, yet it hasn't been provided.
JPOXSQL.UndeclaredParameterError=JPOXSQL query has an undeclared parameter {0} in the SQL
JPOXSQL.ExecutionError=Error executing JPOXSQL query "{0}".

#
# Query Statement
#
RDBMS.QueryStatement.OracleBooleanExpression=OracleAdapter only supports boolean char expressions