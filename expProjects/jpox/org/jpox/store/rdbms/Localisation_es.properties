################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# This program and the accompanying materials are made available under
# the terms of the JPOX License v1.0 which accompanies this distribution.
#
# Resources for org.jpox.store.rdbms package (Spanish)
# Version : $Revision: 1.101.2.1 $
################################################################################

JDBC.Statement.ExecutionTime=Tiempo de cumplir = {0} ms

RDBMS.Connection.SQL.UnallowedOperation=La operación "{0}" no esta permitido

#
# Connection
#
Connection.InvalidCall=No es valido usar el metodo "{0}" de una connección obtenida del PersistenceManager.
Connection.NotAvailable=JDOConnection ya no es disponible

#
# Exceptions
#
RDBMS.Exception = Exception : {0}
RDBMS.Exception.DuplicateColumnName=El nombre de la columna "{0}", de la tabla "{1}" esta duplicado. No se pueden mapear varios campos a una misma columna. El columnas utilizada {2} y {3}.
RDBMS.Exception.DuplicateColumnNameUnknownSource=? datastore-identity|index columns|other non mapped to any field ?
RDBMS.Exception.IncompatibleDataType=El tipo de dato de la columna "{0}" es incompatible : era {1} (datastore), pero debe ser {2} (metadata). Por favor compruebe que el tipo en la base de datos y el tipo en el MetaData son iguales.
RDBMS.Exception.MissingColumn=Las columnas requeridas no existen en la tabla {0} : {1}. Quizas el MetaData sea correcto, o no tiene "org.jpox.autoCreateColumns" como "true".
RDBMS.Exception.MissingTable=La tabla no existe : {2} en Catalog {0} Schema {1}. El MetaData no es correcto, o necesita poner "org.jpox.autoCreateTables" como "true"
RDBMS.Exception.NotATable=La tabla no es del tipo adecuado. Debe ser una tabla : {0} tipo {1}
RDBMS.Exception.NotAView=La tabla no es del tipo adecuado. Debe ser un view : {0} tipo {1}
RDBMS.Exception.PrimaryKeyColumnNotAllowed=No se puede definir una columna de clave primaria en una vista : {0}, columna={1}
RDBMS.Exception.TooManyForeignKeys=Ha excedido el maximum de {0} claves foráneas por la tabla {1}
RDBMS.Exception.TooManyIndices=Ha excedido el maximo de {0} índices por la tabla {1}
RDBMS.Exception.ViewDefinition=La definition de vista para {0} : {1} no es válida
RDBMS.Exception.WrongPrecision=La precision de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData).
RDBMS.Exception.WrongPrimaryKey=La clave primaria de la tabla {0} {1} no existe en la lista de claves {2}
RDBMS.Exception.WrongScale=La scala de la columna {0} no es correcta : era {1} (segun el driver de JDBC) pero debe ser {2} (segun la definicion de MetaData)
RDBMS.Exception.PersistentSuperclassNotAllowed=Las vistas no pueden tener una superclase persistence-capable : {0}
RDBMS.Exception.UnexpectedColumn=La columna {0} encontrado en la tabla {1} schema {2} catalog {3} no debe ser alla 
RDBMS.Exception.IsNullable=La columna {0} no debe permitir nulos pero los permite

#
# SchemaAutoStarter
#
RDBMS.SchemaAutoStarter.ClassesReadError=La recuperación de las clases del SchemaTable ha fallado : {0}
RDBMS.SchemaAutoStarter.ValidationError=La validación del SchemaTable por el esquema "{0}" ha fallado. No lo existe o no es posible validarlo : {1}
RDBMS.SchemaAutoStarter.DropAndCreate=Borrando la tabla {0} y creandola de nuevo
RDBMS.SchemaAutoStarter.AddClassError=La añadación de la clase {0} a la lista de clases manejadas ha fallado. : {1}
RDBMS.SchemaAutoStarter.DeleteClass=Borrando la clase {0} de la lista de clases manejadas
RDBMS.SchemaAutoStarter.DeleteClassError=La borración de la clase {0} de la lista de clases manejadas ha fallado : {1}
RDBMS.SchemaAutoStarter.DeleteClassesError=La borración de todas las clases manejadas ha fallado : {1}
RDBMS.SchemaAutoStarter.StorageDescription=Los nombres de las clases y de las tablas estan almacenados en la tabla "{0}"
RDBMS.SchemaAutoStarter.DatastoreInitialisationException=Unknown error in datastore : {0}

#
# RDBMS Manager
#
RDBMS.Manager.DefaultCatalogNameUnusable=Default Catalog Name "{0}" esta especificado pero el adaptador de la base de datos (JDBC driver) no apoya la especificacion del nombre del catalogo
RDBMS.Manager.DefaultSchemaNameUnusable=Default Schema Name "{0}" esta especificado pero el adaptador de la base de datos (JDBC driver) no apoya la especificacion del nombre de la esquema

RDBMS.Manager.DatabaseInitialisationError=La inicialización del base de datos ha fallado.
RDBMS.Manager.DatabaseConnectionError=Obtener una connección al base de datos da un error.
RDBMS.Manager.DatabaseInitialisationAdvice=Por favor, compruebe que el nombre, el usuario y la contraseña de la base de datos son correctos.

RDBMS.Manager.SchemaDataInitialise=Inicializando el Catalogo "{0}", el Esquema "{1}" con el sistema de AutoStart "{2}"
RDBMS.Manager.SchemaDataInitialised=El Catalogo "{0}", el Esquema "{1}" esta inicializado - con {2} clases
RDBMS.Manager.SchemaDataInitialisedReadOnly=El Catalogo "{0}", el Esquema "{1}" esta inicializado - con {2} clases [SOLO PARA LEER]
RDBMS.Manager.SchemaDataInitialisedFixed=El Catalogo "{0}", el Esquema "{1}" esta inicializado - con {2} clases [FIJADO]
RDBMS.Manager.SchemaDataUninitialisedForSchema=El SchemaData no es inicializado por el Catalogo "{0}", el Esquema "{1}"

RDBMS.Manager.AddSchemaData=Manejar la persistencia de {0}
RDBMS.Manager.UnableToFindSuperclassTable=La clase {0} tiene una estrategia de heredar de "superclass-table", pero no hay una tabla de una superclase!
RDBMS.Manager.NoTableForEmebeddedClass=La clase "{0}" tiene "embedded-only", asi que se puede persistir objetos solamente en las tablas de otras clases. No vamos a crear una tabla.

RDBMS.Manager.TableAlreadyInUse=La clase ({0}) tiene un nombre de tabla de {1}, pero esa tabla es de otra clase ({2}). JPOX va a usar otra definicion de la misma tabla y va a persistir objetos de las dos clases a la misma tabla en la base de datos. Es su responsibilidad asegurar que las dos clases son compatibles.

RDBMS.Manager.JoinTableCreationError=Crear las tablas de Set es posible como efecto de añadir una clase nueva solamente

RDBMS.Manager.DropTablesFromSchema=Borrar las tablas del Catalogo "{0}", del Esquema "{1}"
RDBMS.Manager.DropTablesError=No hay una tabla de esquema, asi que no hay tablas para borrar

RDBMS.Manager.PersistentClassNotFound=La clase persistente con id "{0}" no esta
RDBMS.Manager.ObjectWithIdNotFound=¡Objeto con el id "{0}" no existe!
RDBMS.Manager.NewObjectAIDInvalidClassError=Intenta de encontrar nueva identidad de application-identity para la clase ({0}) pero no usa "application identity".
RDBMS.Manager.NewObjectAIDInvalidFieldType=Intenta de encontrar nueva identidad de application-identity para la clase {0} pero el campo {1} no es de un tipo valido ({2}). Debe ser int/long/Integer/Long.

RDBMS.Manager.ObjectIdClassDuplicated=La clase {0} esta definido usar el objectid-class {1}, pero este ya esta definido por otro arbol de herencia (e.g por la clase {2}). Usted debe corregirlo para que cada arbol de herencia usa su propio objectid-class.
RDBMS.Manager.IDAssignedToIncorrectClass=Id {0} is assigned to class {1}, but it's not the correct object-id type for this class.

RDBMS.Manager.ObtainingNextIDForClass=Obtener identidad proxima por la clase {0}
RDBMS.Manager.POIDConnectionOpenError=Error durante el proceso obtener la conexión por la generación de POID : {0}
RDBMS.Manager.POIDConnectionCloseError=Error durante el proceso cerrar la conexión por la generación de POID : {0}
RDBMS.Manager.StrategyValueGenerated=Valor creado por campo "{0}" con la estrategia="{1}" (PoidGenerator="{2}") : valor={3}

RDBMS.Manager.ColumnInfoLoaded=Información de columna cargado por el Catalogo "{0}", el Esquema "{1}", {2} tablas, tiempo = {3} ms
RDBMS.Manager.ColumnInfoNotFoundForTable=No hay información de columna por la tabla "{0}"; la tabla no existe en la base de datos
RDBMS.Manager.ColumnInfoNotFound=No hay información de columna por la columna "{0}" de la tabla "{0}"
RDBMS.Manager.ColumnInfos=Información de columna cargado por la tabla "{0}" : hemos encontrado {1} columnas
RDBMS.Manager.ColumnInfo=Información de columna cargado por la columna "{0}" de la tabla "{1}"
RDBMS.Manager.TableIDColumnError=No hay columna de identidad por la clase {0}
RDBMS.Manager.FieldTableError=Campo {0}.{1} no tiene una tabla propia para buscar {2}
RDBMS.Manager.InvalidPseudoFieldNameForSet=El nombre pseudo-campo {0} no existe en el macro {1}, debe ser "owner" o "element"
RDBMS.Manager.InvalidPseudoFieldNameForMap=El nombre pseudo-campo {0} no existe en el macro {1}, debe ser "owner", "key" o "value"

RDBMS.Manager.AddClassesToSchema=Añadir las clases al Catalog "{0}", al Esquema "{1}"
RDBMS.Manager.AddClassesError=Añadacion de las clases ha fallado como la transacción no es activo
RDBMS.Manager.AddTablesRollback=Hay un error en la creación de los elementos del esquema - restaurando
RDBMS.Manager.AddTablesRollbackError=Habia un error durante la auto creacion de los elementos del esquema. La excepcion siguiente ocurrio durante el proceso de restaurar lo de antes : {0}
RDBMS.Manager.AddClassesInvalidClassError=Clase o juncion referenciada {0} no es persistence-capable !
RDBMS.Manager.AutoCreateError=Hemos encontrado unos errores durante la validación o creación de las tablas. Los errores estan en el log, y estan adjuntados a esta excepción.
RDBMS.Manager.AddClassesExceptionError=Una excepcion estaba tirada durante la addicion/validacion de algunas class(es) : {0}
RDBMS.Manager.RemoveAllClassesFromSchema=Borrando todas las clases de persistencia por el catalogo "{0}", esquema "{0}"
RDBMS.Manager.RemoveClass=Borrando la clase "{0}" de persistencia
RDBMS.Manager.RemoveClassesExceptionError=Una excepcion estaba tirada durante la borracion de algunas class(es) : {0}

RDBMS.Manager.InvalidGeneratedId=Invalid Id generated for field {0}, id : {1}

RDBMS.Manager.NonPersistenceCapableCollectionElementNeedsJoin=No <join> metadata found for field {0} with non PersistenceCapable elements/values. This metadata {1} needs adding the join. 

RDBMS.Manager.MapWithoutJoinWithoutMappedBy=El campo "{0}" es una mapa que no tiene una tabla para juntar y ni la clase ni el valor tiene "mapped-by". ¡Es invalido!

RDBMS.Manager.InvalidArgumentForQuery=Argumento de Query {0} : debe ser un String con el filter, o otro Query para usar como el basis

#
# RDBMS Adapter
#
RDBMS.Adapter.NoAdapterFound=No hemos encontrado un adaptador por el Driver de JDBC. Usando "DatabaseAdapter" generico.
RDBMS.Adapter.AdapterClassNotFound=No hemos encontrado la clase de adaptador de la base de datos "{0}". Por favor, compruebe que existe en el CLASSPATH.

RDBMS.Adapter.OracleAdapterNotFound=El adaptador de Oracle no existe
RDBMS.Adapter.MetaDataAccessError=Utiliza el MetaData del base de datos da un error
RDBMS.Adapter.JDBCTypeNotSupported=El tipo de JDBC "{0}" no es apoyado por el JDBC de este base de datos. Por favor compruebe el valor de "jdbc-type" y las capacidades de JDBC.
RDBMS.Adapter.JDBCTypesNotSupported=Ningun de los tipos de JDBC son apoyados
RDBMS.Adapter.SQLTypeDiscardedForJDBCType=Tipo de SQL "{0}" (para le tipo de JDBC "{1}") estaba descartado por el adaptador del base de datos

RDBMS.Adapter.TransactionIsolationUnsupported=No apoya el nivel de isolación de transacciones {0}. No usado.

RDBMS.Adapter.MappingFieldError=Puede usa {0} con un campo persistence-capable
RDBMS.Adapter.MappingConstructorMissing=El constructor {0}(ClassBaseTable,int) no existe
RDBMS.Adapter.MappingFieldNotSupported=Campos del tipo {0} no son apoyados
RDBMS.Adapter.MappingConstructorError=No es posible usar el constructor del objeto mapping con la clase {0}
RDBMS.Adapter.MappingInstantiationError=No es posible crear un objeto mapping mapping con la clase {0}
RDBMS.Adapter.MappingConstructorFailure=El Constructor de {0} ha fallado

RDBMS.Adapter.CatalogNameError=No sabe como determinar el nombre del catalogo por este tipo de RDBMS : {0} {1}
RDBMS.Adapter.SchemaNameError=No sabe como determinar el nombre del esquema por este tipo de RDBMS : {0} {1}

RDBMS.Adapter.CatalogsInTableDefinitions=El adaptador permite el catalogo en la definicion de las tablas
RDBMS.Adapter.SchemasInTableDefinitions=El adaptador permite la esquema en la definicion de las tablas

RDBMS.Adapter.AutoIncrementNotSupported=Este adaptador no apoya llaves auto-increment
RDBMS.Adapter.SequenceNotSupported=Este adaptador no apoya sequencias
RDBMS.Adapter.SequenceNameNullNotSupported=Este adaptador no apoya sequencias sin nombres

RDBMS.Adapter.JDBC.NoProductNameError=Error : Este Driver de JDBC no tiene un nombre de producto. No era posible elegir un adaptador de RDBMS.
RDBMS.Adapter.JDBC.ProductNameAccessError=Error : Este Driver de JDBC dio un error al punto de obtener el nombre de producto. No era posible elegir un adaptador de RDBMS : {0}
RDBMS.Adapter.InstantiationError=Error : Un error ocurrio cuando creando un adaptador "{0}" para este Driver de JDBC : {1}

RDBMS.Adapter.Derby.InitialisationError=Error initialising derby schema : {0}

#
# Connection
#
RDBMS.Connection.Opened=Hemos abierto una connección "{0}" con nivel de isolación "{1}"
RDBMS.Connection.Closed=Hemos cerrado una connección "{0}"

#
# TypeInfo
#
TypeInfo.UnrecognizedDatatype=Data type {0} no esta reconocido por JDBC. Va a ignorar la validación

#
# Extent
#
RDBMS.Extent.ClassHasNoPersistentFields=No se puede crear el Extent porque la clase "{0}" no tiene campos persistentes
RDBMS.Extent.MappingInvalidForView=No se puede crear el Extent porque la asociación del campo "{0}" no es apropiada de una columna de View, para la clase "{1}"
RDBMS.Extent.ClassNotFound=No se puede crear el Extent para la clase "{0}" porque le hace falta la clase "{1}" y no existe en el CLASSPATH!

#
# Column
#
RDBMS.Column.FieldPrecisionInvalid=La columna {0} tiene una precision/escala, pero el tipo de la columna de la base de datos no permite nada.
RDBMS.Column.PrecisionError=La precisión no es valido, columna = {0}

#
# Column creation
#
RDBMS.ColumnCreation.FieldShouldBeSubclassTableButIsnt=Field "{0}" should be using "subclass-table" inheritance strategy yet isnt. Please report this.
RDBMS.ColumnCreation.DeclaredColumnsError=El campo "{0}" esta declarado para usar algunas claves ajenas y tiene una especificacion de las columnas, pero el numero de columnas ({1}) no es igual que el numero de claves ajenas de este campo ({2}).
RDBMS.ColumnCreation.ColumnAddedForSubclassType=Una columna añadido por el tipo "{0}" del campo "{1}" (declarada para usar "subclass-table")
RDBMS.ColumnCreation.ColumnAddedForReferenceType=Una columna añadido por la implementación "{0}" del campo "{1}" (declarada como referencia - "interface" o java.lang.Object)
RDBMS.ColumnCreation.ImplementationClassNotFound=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) y debe tener una implementación "{1}", pero esta clase no existe!
RDBMS.ColumnCreation.ImplementationClassIsInterface=¡El campo "{0}" esta declarado como referencia ("interface" o java.lang.Object) y debe tener una implementación "{1}" pero este es Interface también!

#
# Request
#
RDBMS.Request.InsertWithNoPrimaryKeyError=Intenta de poner un objeto de la clase "{0}" pero sin campos de identidad (de application identity).
RDBMS.Request.OptimisticVersionMismatch=El objeto con id "{0}" en la tabla {1} ha cambiado en la base de datos despues de la ultima leer. Version en la base de datos es "{2}" pero la version de la transaccion es "{3}"
RDBMS.Request.OptimisticVersionMissing=El objeto con id "{0}" en la tabla {1} ha sido borrado de la base de datos despues de la ultima leer.
RDBMS.Request.InsertOfAutoincrementReturnedNullIdentity=El objeto estab puesto en la base de datos table {0} con una columna de "autoassign"/"identity", pero la base de datos dice que la identidad es nulo. Es un bug en la base de datos. Usted tiene que usar otra estrategia por este campo.

#
# Fetch
#
RDBMS.FetchStatement.MappingsHaveInconsistentNumbersOfFields=Una pedida de obtener datos de una tabla con llave primaria con {0} columnas, pero el campo con que necesita juntar tiene {1} columnas! Por favor, informanos por el Forum de JPOX!

#
# Mappings
#
RDBMS.MappingManager.UnknownSQLTypeForJavaType=No podemos manejar el tipo de SQL {1} por el tipo de Java {0} con este base de datos.
RDBMS.MappingManager.UnknownJDBCTypeForJavaType=No podemos manejar el tipo de JDBC {1} por el tipo de Java {0} con este base de datos.
RDBMS.MappingManager.UnsupportedJavaType=No podemos manejar el tipo de Java {0} (jdbc-type="{1}, sql-type="{2}"). No apoyamos este tipo.
RDBMS.MappingManager.UnknownSQLType=No podemos manejar el tipo de SQL {1} del campo {0} con este base de datos.
RDBMS.MappingManager.UnknownJDBCType=No podemos manejar el tipo de JDBC {1} del campo {0} con este base de datos.
RDBMS.MappingManager.UnsupportedType=No podemos manejar el tipo de Java {1} del campo {0} con este base de datos y con el tipo de JDBC/SQL puesto. Por favor, intentalo con otro tipo de JDBC/SQL, o dejalo vacio para JPOX usar el default.

RDBMS.Mapping.NoTypeFoundForColumn=No hay un tipo de JDBC por la columna "{0}"
RDBMS.Mapping.UnableToSetParam=No puede poner parametro de tipo {0} : valor = {1} en la columna "{2}" : {3}
RDBMS.Mapping.UnableToGetParam=No puede obtener el resuelto de tipo {0} por el parametro = {1} en la columna "{2}" : {3}
RDBMS.Mapping.IllegalNullValueInColumn=Nulo es invalido en la columna {0}
RDBMS.Mapping.IllegalValueInColumn={0} es invalido en la columna {1}
RDBMS.Mapping.ObjectNotSerializable=Objeto de tipo {0} no es Serializable
RDBMS.Mapping.IllegalValueForBooleanInColumn=Campo de boolean/Boolean almacenado en columna de tipo "{0}" tiene valor ilegal "{1}" al leerlo!
RDBMS.Mapping.DataLongerThanColumn=Intento de poner el valor "{0}" en la columna "{1}" que tiene tamaño maximo de {2}. Por favor corrige el valor

#
# SCO
#
RDBMS.SCO.ArrayMetaDataMissing=¡El campo "{0}" es una matriz, pero no hay MetaData de <array>!
RDBMS.SCO.CollectionMetaDataMissing=¡El campo "{0}" es una collección, pero no hay MetaData de <collection>!
RDBMS.SCO.MapMetaDataMissing=¡El campo "{0}" es una mapa, pero no hay MetaData de <map>!
RDBMS.SCO.ElementMetaDataNotFound=¡El MetaData de la clase de elemento "{0}" del campo de collección "{1}" no esta!
RDBMS.SCO.ValueMetaDataNotFound=¡El MetaData de la clase de elemento "{0}" del campo de mapa "{1}" no esta!
RDBMS.SCO.IteratorStatementIsNull=El estatement del iterador es nulo !!
RDBMS.SCO.IteratorRequestFailed=Solicitud de iterar ha fallado : {0}
RDBMS.SCO.SizeRequestFailed=Solicitud de tamaño ha fallado : {0}
RDBMS.SCO.ContainsRequestFailed=Solicitud de contener ha fallado : {0}
RDBMS.SCO.AddRequestFailed=Solicitud de añadir ha fallado : {0}
RDBMS.SCO.UpdateEmbeddedKeyFailed=Solicitud de cambiar la clave embedded ha fallado : {0}
RDBMS.SCO.UpdateEmbeddedValueFailed=Solicitud de cambiar el valor embedded ha fallado : {0}
RDBMS.SCO.RemoveRequestFailed=Solicitud de borrar ha fallado : {0}
RDBMS.SCO.ClearRequestFailed=Solicitud de vaciar ha fallado : {0}
RDBMS.SCO.GetRequestFailed=Solicitud de obtener ha fallado : {0}
RDBMS.SCO.SetRequestFailed=Solicitud de poner ha fallado : {0}
RDBMS.SCO.PutRequestFailed=Solicitud de poner ha fallado : {0}
RDBMS.SCO.IndexofRequestFailed=Solicitud de IndexOf ha fallado : {0}
RDBMS.SCO.ContainsKeyRequestFailed=Solicitud de ContainsKey ha fallado : {0}
RDBMS.SCO.ContainsValueRequestFailed=Solicitud de ContainsValue ha fallado : {0}
RDBMS.SCO.MaxAdapterColumnIdRequestFailed=Solicitud de MaxAdapterColumnId ha fallado : {0}
RDBMS.SCO.QueryOverCollectionImpossible=No se puede preguntar sobre una Collection de elementos de segunda clase
RDBMS.SCO.QueryOverMapImpossible=No se puede preguntar sobre un Map de valores de segunda clase
RDBMS.SCO.GetIndicesFailed.InvalidElements=GetIndices ha fallado : unos elementos no existen : {0}

RDBMS.SCO.MappedByNonExistent=El campo "{0}" tiene "mapped-by" como "{1}" pero ese campo "mapped-by" no existe en la clase "{2}".
RDBMS.SCO.MappedByTypeInvalid=El campo "{0}" tiene "mapped-by" como "{1}" pero el tipo de ese es incorrecto ({2}). El campo de "mapped-by" tiene que ser del tipo "{3}"
RDBMS.SCO.InverseOwnerMappedByFieldInvalidType=El campo dueño {0} de la clase de elemento {1} tiene un tipo incorrecto "{2}". Debe ser "{3}"
RDBMS.SCO.UpdateFkRequestFailed=Could not update the foreign key using statement : {0}

#
# SCO Collection
#
RDBMS.SCO.Collection.WriteInvalidWithDifferentPM=No se puede escribir elemento de otro Persistence Manager
RDBMS.SCO.Collection.CannotContainEmbeddedElement=El campo de collección "{0}" debe contener el elemento "{1}" pero este elemento esta almacenado como "embedded" en otro campo. ¡Es imposible!. No se puede almacenar un objeto como SCO ("embedded") y como FCO al mismo tiempo

RDBMS.SCO.Collection.InverseOwnerMappedByFieldNotPresent=La clase "{0}" tiene campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
RDBMS.SCO.Collection.InverseOwnerFieldNotPresent=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"

RDBMS.SCO.Collection.ElementWithSubclassTableWithMultipleTablesNotSupported=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. JPOX no apoya esta situación.
RDBMS.SCO.Collection.InterfaceElementNotSupported=La collección tiene element-type "{0}" que es interface y tiene más que una implementación. JPOX no apoya el uso de los interfaces cuando haya más que una implementación disponible.

RDBMS.SCO.Collection.ElementIsInvalid=La clase {0} no es de un tipo valido para esta collección (Campo "{1}"). Debe ser "{2}" o algun subclase

RDBMS.SCO.Collection.ClearElementsFromInverseDeleteDependent=La borracion del elemento de FK Collection ha borrado los elementos porque el campo es "dependent"
RDBMS.SCO.Collection.ClearElementsFromInverseDelete=La borracion del elemento de FK Collection ha borrado los elementos porque las columnas de owner/index no son nulable
RDBMS.SCO.Collection.ClearElementsFromInverseNull=La borracion del elemento de FK Collection ha quitado los elementos de la Collection y los ha dejado en la base de datos.

#
# SCO Set
#
RDBMS.SCO.Set.WriteInvalidWithDifferentPM=No se puede escribir elemento de otro Persistence Manager
RDBMS.SCO.Set.NullElementsNotAllowed=Elementos nulos no estan permitidos en persistent sets.
RDBMS.SCO.Set.ElementAlreadyExistsinMtoN=El campo de collección "{0}" tenia que añadir el elemento "{1}" a la relación M-N pero este elemento ya existe.

#
# SCO List
#
RDBMS.SCO.List.InverseIndexFieldNotPresent=La clase "{0}" tiene un campo de collección "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}". ¿Quizas usted haya declarado el campo como java.util.Collection pero lo haya instanciado como java.util.List sin poner <order> en el MetaData?
RDBMS.SCO.List.WriteInvalidWithDifferentPM=No se puede escribir elemento de otro Persistence Manager
RDBMS.SCO.List.RemoveElementFromInverseDelete=La borracion del elemento de Inverse List ha borrado el elemento porque las columnas de owner/index no son nulable
RDBMS.SCO.List.RemoveElementFromInverseNull=La borracion del elemento de Inverse List ha quitado el elemento de List y lo ha dejado en la base de datos.
RDBMS.SCO.List.OrderColumnMissing=El campo "{0}" ha sido instanciado como una lista usando tabla de juntar pero la tabla no tiene una columna de "order". Por favor, ponga un elemento <order> en el MetaData.

#
# SCO Array
#
RDBMS.SCO.Array.ElementWithSubclassTableWithMultipleTablesNotSupported=El campo "{0}" es una collección con elementos que usan la estrategia de heredar de "subclass-table" y hay más que una tabla basica para los elementos. JPOX no apoya esta situación.
RDBMS.SCO.Array.InverseOwnerMappedByFieldNotPresent=La clase "{0}" tiene campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}" campo "{3}"
RDBMS.SCO.Array.InverseOwnerFieldNotPresent=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping en la tabla de la clase de elementos "{2}"
RDBMS.SCO.Array.InverseIndexFieldNotPresent=La clase "{0}" tiene un campo de matriz "{1}" pero este no tiene un Mapping por el indice de la lista en la tabla de la clase de elementos "{2}"
RDBMS.SCO.Array.InterfaceElementNotSupported=La matriz tiene element "{0}" que es interface y tiene más que una implementación. JPOX no apoya el uso de los interfaces cuando haya más que una implementación disponible.

#
# SCO Map
#
RDBMS.SCO.Map.InverseKeyFieldNotSpecified=La Mapa "{0}" no tiene ninguna especificacion <key mapped-by=...>. Usted tiene que poner un <key mapped-by=...> porque se almacena la llave en un campo en el valor.
RDBMS.SCO.Map.InverseKeyFieldTypeIncompatible=¡La Mapa "{0}" tiene un tipo de llave de "{1}" pero el campo de la llave en el valor es de tipo "{2}"!
RDBMS.SCO.Map.InverseKeyFieldNotFound=¡La clase de valor "{0}" tiene que contener un campo "{1}" que representa la llave, pero no hay ningun campo con este nombre!

RDBMS.SCO.Map.InverseValueFieldNotSpecified=La Mapa "{0}" no tiene ninguna especificacion <value mapped-by=...>. Usted tiene que poner un <value mapped-by=...> porque se almacena el valor en un campo en la llave.
RDBMS.SCO.Map.InverseValueFieldTypeIncompatible=¡La Mapa "{0}" tiene un tipo de valor de "{1}" pero el campo de; valor en la llave es de tipo "{2}"!
RDBMS.SCO.Map.InverseValueFieldNotFound=¡La clase del llave "{0}" tiene que contener un campo "{1}" que representa el valor, pero no hay ningun campo con este nombre!

RDBMS.SCO.Map.InverseOwnerKeyFieldNotPresent=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de los valores "{2}" campo de llave "{3}"
RDBMS.SCO.Map.InverseOwnervalueFieldNotPresent=La clase "{0}" tiene un campo de Mapa "{1}" pero no tiene un Mapping para la clase de las llaves "{2}" campo de valor "{3}"
RDBMS.SCO.Map.InverseOwnerMappedByFieldInvalidType=The owner field {0} of value class {1} has an incorrect type "{2}". Should be "{3}"
RDBMS.SCO.Map.InverseOwnerFieldNotPresent=¡La clase "{0}" tiene un campo de Mapa "{1}" pero no hay ningun Mapping en la tabla de la clase de valores "{2}" para llegar al dueño!

RDBMS.SCO.Map.WriteKeyInvalidWithDifferentPM=No se puede escribir la llave de otro Persistence Manager
RDBMS.SCO.Map.WriteValueInvalidWithDifferentPM=No se puede escribir valor de otro Persistence Manager
RDBMS.SCO.Map.NullKeysNotAllowed=Llaves nulas no estan permitidas en persistent maps.
RDBMS.SCO.Map.NullValuesNotAllowed=Valores nulos no estan permitidos en persistent maps.
RDBMS.SCO.Map.KeyIsInvalid=La clase {0} no es de un tipo valido para una llave de este Map. Debe ser {1}
RDBMS.SCO.Map.ValueIsInvalid=La clase {0} no es de un tipo valido para un valor de este Map. Debe ser {1}
RDBMS.SCO.Map.InterfaceValueNotSupported=El Mapa tiene value-type "{0}" que es interface. JPOX no apoya totalmente un value-type asi. Por favor cambialo por una clase.
RDBMS.SCO.Map.MappedByNonExistent=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero este campo de "mapped-by" no existe en la clase "{2}".
RDBMS.SCO.Map.MappedByTypeInvalid=El campo "{0}" tiene un "mapped-by" con el campo "{1}" pero el tipo esta incorrecta ({2}). El campo de "mapped-by" debe ser de tipo "{3}"

RDBMS.SCO.Map.KeyMetaDataNotFound=¡El MetaData de la clase de la llave "{0}" del campo de la mapa "{1}" no esta!
RDBMS.SCO.Map.ValueMetaDataNotFound=¡El MetaData de la clase del valor "{0}" del campo de la mapa "{1}" no esta!

RDBMS.SCO.Map.InverseKeyValueMappedNotSpecified=El campo "{0}" es una mapa de ForeignKey. No hay ningun key/value "mapped-by". Usted tiene que poner <key mapped-by="..."> para usar una relación de mapa de ForeignKey.
RDBMS.SCO.Map.InverseKeyStoredInValueButValueNotPC=El campo "{0}" es una mapa de ForeignKey donde se almacena la llave en el valor, pero el valor no es PersistenceCapable (es "{1}"). Usted tiene que usar un valor de PersistenceCapable para usar este tipo de relación
RDBMS.SCO.Map.InverseKeyStoredInValueButValueNotPC=El campo "{0}" es una mapa de ForeignKey donde se almacena el valor en la llave, pero la llave no es PersistenceCapable (es "{1}"). Usted tiene que usar una llave de PersistenceCapable para usar este tipo de relación
RDBMS.SCO.Map.InverseValueStoredinKeyButKeyNotSupported=El campo "{0}" es una mapa de ForeignKey donde el valor se almacena en la llave, pero JPOX no apoya esta relación

#
# RDBMS Tables
#
RDBMS.Table.AlreadyInitialisedError=Ya existe la tabla : {0}
RDBMS.Table.UninitialisedError=La tabla no ha sido inicializada : {0}
RDBMS.Table.NotValidatedError=La tabla no ha sido validada : {0}

RDBMS.Table.ClassHasNoTableError=Intenta de crear una tabla por la clase {0} que tiene una estrategia de heredar de "{1}". No debe tener su propia tabla.
RDBMS.Table.NondurableIdentityUnsupported=La clase {0} necesita una identidad
RDBMS.Table.InvalidIdentityType=El tipo de identidad de la clase {0} no es valido
RDBMS.Table.InvalidPersistenceModifierForField=El persistence-modifier del campo {0} no es valido

RDBMS.Table.InvalidMapKeyField=El campo "{0}" representa una mapa con la clave almacenada como un campo del valor, pero el campo ({1}) no existe en el valor.
RDBMS.Table.InvalidMapValueField=El campo "{0}" representa una mapa con el valor almacenado como un campo de la clave, pero el campo ({1}) no existe en la clave.
RDBMS.Table.MissingMapKeyValueField=El campo "{0}" representa una mapa sin tabla de juntar. Usted tiene que poner "mapped-by" para marcar que la clave esta almacenado con la clase del valor, o el valor esta almacenado con la clase de la clave.

RDBMS.Table.FieldToColumnMapping=Campo [{0}] -> Columnas [{1}] usando mapping del tipo "{2}" ({3})

RDBMS.Table.DuplicateMapOwnerField=Más que un mapa tiene su "mapped'by" puesto como el campo "{0}" (por ejemplo el campo "{1}"). Este puede causar problemas porque objetos de esta clase pueda ser parte de muchas relaciones y cosas como "dependent-field" posiblemente no va a funcionar correctamente debido a esta situación

RDBMS.Table.ClassObjectInfo=Tabla clase={0}, object-class={1}

RDBMS.Table.Array.ElementHasNoMetaData=La clase "{0}" tiene una matriz con elemento "{1}" pero este elemento no tiene MetaData.

RDBMS.Table.CollectionMetaDataError=No hay MetaData de <collection> por el campo {0}
RDBMS.Table.Collection.ElementHasNoMetaData=La clase "{0}" tiene una collección con elemento "{1}" pero este elemento no tiene MetaData.

RDBMS.Table.MapMetaDataError=No hay MetaData de <map> por el campo {0}
RDBMS.Table.Map.ValueHasNoMetaData=La clase "{0}" tiene un Map con valor "{1}" pero este valor no tiene MetaData.
RDBMS.Table.Map.KeyHasNoMetaData=La clase "{0}" tiene un Map con clave "{1}" pero esta clave no tiene MetaData.

RDBMS.Table.OrderMappingMappedByFieldNotFound=El campo "{0}" tiene un <order> que debe almacenar en la columna del campo de elemento "{1}". ¡Este campo no existe!
RDBMS.Table.OrderMappingFieldInvalid=El campo "{0}" tiene un <order> que debe almacenar en la columna del campo de elemento "{1}". ¡Es invalido! Debe ser int/Integer.

RDBMS.Table.AutoIncrementNotSupportedByRDBMS=La clase "{0}" tiene campo "{1}" con autoassign/identity, pero la base de datos no apoya esa facilidad.
RDBMS.Table.OwnerHasNoTable=La clase "{0}" no tiene su propia tabla y no hay subclases con tablas tampoco. No es posible crear el esquema!
RDBMS.Table.ManagingClassFields=La tabla {0} va a manejar la persistencia de los campos de la clase {1} (estrategia de heredar="{2}")

RDBMS.Table.SchemaNameUndeterminable=No era posible determinar el nombre del esquema por este DataStore
RDBMS.Table.CatalogNameUndeterminable=No era posible determinar el nombre del catalogo por este DataStore
RDBMS.Table.ProbeTableError=No era posible encontrar la tabla del Probe {0}

RDBMS.Table.Error=Un error estaba tirado con {0} : {1}

RDBMS.Table.Creating=Crear la tabla {0}
RDBMS.Table.Dropping=Borrar la tabla {0}
RDBMS.Table.CreatingColumn=Crear la columna {0} de la tabla {1}
RDBMS.Table.Validating=Validar la tabla : {0}

#
# RDBMS Views
#
RDBMS.View.Validating=Validar la vista : {0}
RDBMS.View.IdentityTypeNotSupported=La clase "{0}" has been defined with an identity-type of "{1}". SQL Views cannot be used with this type. You must use "nondurable".
RDBMS.View.InvalidPersistenceModifierForField=Class "{0}" has been defined with field "{1}" with a persistence-modifier of "{2}". You cannot use this with SQL Views - must be persistent or transactional.
RDBMS.View.OperationNotSupported=Class "{0}" uses an SQL View, however the method "{1}" has just been called. This is not supported for SQL Views.
RDBMS.View.IdentityGenerationNotSupported=Class "{0}" uses an SQL View consequently JPOX doesnt support the generation of new identities for objects of this type.
RDBMS.View.MacrosNotAllowedInViewDefinition=Class "{0}" uses an SQL View, however you are not allowed to use macros (such as "{1}") in the view definition.

#
# Indices
#
RDBMS.Table.Index.Creating=Crear el indice "{0}" en catalogo "{1}" equema "{2}"
RDBMS.Table.Index.ColumnNotFound=La tabla "{0}" tiene un indice "{1}" y una columna ("{2}") no esta.
RDBMS.Table.Index.NoColumnsSpecified=La tabla "{0}" tiene un indice "{1}" pero no tiene columnas.
RDBMS.Table.Index.MissingIndexes=Los indices no existen en {0} : {1}
RDBMS.Table.Index.Validated=Validado {0} indic(es) de la tabla {1}
RDBMS.Table.Index.FieldNotFound=Un indice "{0}" tiene un campo "{1}" pero este campo no existe

#
# Foreign Keys
#
RDBMS.Table.ForeignKey.Creating=Crear el constreñimiento del foreign key "{0}" en catalogo "{1}" equema "{2}"
RDBMS.Table.ForeignKey.MissingForeignKeys=Los foreign keys no existen en {0} : {1}
RDBMS.Table.ForeignKey.Dropping=Borrando {0} foreign key(s) de la tabla {1}
RDBMS.Table.ForeignKey.Validated=Validado {0} foreign key(s) de la tabla {1}

#
# Candidate (Unique) Keys
#
RDBMS.Table.CandidateKey.Creating=Crear la llave unica "{0}" en catalogo "{1}" equema "{2}"
RDBMS.Table.CandidateKey.MissingIndexes=Las llaves unicas no existen en {0} : {1}
RDBMS.Table.CandidateKey.ColumnNotFound=La tabla "{0}" tiene una llave unica "{1}" y una columna ("{2}") no esta.
RDBMS.Table.CandidateKey.NoColumnsSpecified=La tabla "{0}" tiene una llave unica "{1}" pero no tiene columnas.
RDBMS.Table.CandidateKey.Validated=Validado {0} llaves unicas de la tabla {1}
RDBMS.Table.CandidateKey.FieldNotFound=Una llave unica "{0}" tiene un campo "{1}" pero este campo no existe


RDBMS.Table.NewColumn=La columna "{0}" añadió a la representación de la table.
RDBMS.Table.PrimaryKeyColumnNotMapped=La columna de Primary Key "{0}" de la tabla "{1}" no esta designada
RDBMS.Table.RelationshipMappedByFieldNotFound=No hemos encontrado el campo "{0}" de la clase "{1}" con una relación el campo "{2}"

RDBMS.Table.ApplicationIdentitySequenceTypeInvalid=Los tipos de Application identity sequence (auto-increment) son long, Long, int o Integer, pero {0} esta especificado.
RDBMS.Table.ApplicationIdentitySequenceType2Invalid=Los tipos de Application identity sequence (auto-increment) son long, Long, int, Integer o String, pero {0} esta especificado.

RDBMS.Table.PrimaryKeyVendorExtensionDeprecatedFeature=La extensión de primary-key esta deprecada. Debe usar una clase de application-identity en vez de este.

RDBMS.Table.PrimaryKeyColumnNotFound=La tabla "{0}" debe tener un primary-key con la columna "{1}" pero esta columna no existe en la tabla. Por favor compruebe la especificación de <primary-key>.

RDBMS.Table.KeyTypeMapColumnOverwriteValueTypeMapColumn=El tipo de clave dado por el campo de Map {0} usa una columna que ya estaba usado por el tipo de valor del campo de Map.
RDBMS.Table.ValueTypeMapColumnOverwriteKeyTypeMapColumn=El tipo de valor dado por el campo de Map {0} usa una columna que ya estaba usado por el tipo de clave del campo de Map.

#
# SecondaryTable
#
RDBMS.Table.Secondary.PrimaryTableNotSpecified=No es posible crear una tabla secundaria ("{0}") sin la tabla primaria!

#
# CorrespondentColumnsMapping
#
RDBMS.CorrespondentColumnsMapping.ColumnNumbersMismatch=Las columnas "{0} " han sido definido con {1} columnas, pero hay solamente {2} en otro lado!
RDBMS.CorrespondentColumnsMapping.ColumnTargetDoesntExist=Las columnas "{0}" tiene una columna "{1}" que ha sideo definido associar con "{2}" pero este no existe!
RDBMS.CorrespondentColumnsMapping.NoRemainingColumnsToMapTo=Las columnas "{0}" numero de columna {1} no tiene otras columnas para asociar!
RDBMS.CorrespondentColumnsMapping.ColumnMappedTwice=Las columnas "{0}" tiene una columna "{1}" que ha sido asociado dos veces!

#
# Naming
#
Naming.FileNonExistent=File {0} doesn't exist. Check your path or classpath.
Naming.ErrorReadingFile=Error reading Naming file {0} : {1}
Naming.ResolveEntity=resolveEntity({0}, {1})

#
# FieldManager
#
ParameterSetter.FieldCannotBeNull=El campo {0} es nulo, pero es obligatorio como esta en el MetaData de JDO

#
# Poid Generators
#
SequencePoidGenerator.CantCreateSequence=No podíamos crear la sucesión "{0}"
SequencePoidGenerator.CantObtainSequenceId=No podíamos obtener una nueva sucesión (unique id) : {0}

#
# Query Statement
#
QueryStatement.RangeVariableInUse=El variable del surtido {0} ya esta en uso en pregunta : {1}
QueryStatement.RangeVariableError=El variable del surtido {0} no existe
QueryStatement.DistinctWithForUpdateNotAllowedForRDBMS=¡El Query necesitaba DISTINCT, pero no era posible poner "FOR UPDATE" porque la base de datos no permite un sintaxis asi!
QueryStatement.OrderByExpressionInconsistency=La clausa de "ORDER BY" necesita el mismo número de expresiones y direcciones, pero ha recibido {0} expresiones y {1} direcciones!
QueryStatement.SyntaxNotSupportedByDatastore=La base de datos que usted usa no apoya el sintaxis necesario para esta operación "{0}"

#
# Query Result
#
QueryResult.Closed=El resultado del Query ya esta cerrado
QueryResult.ReadError=Ha encontrado un error leyendo el ResultSet : {0}
QueryResult.NoMoreElements=No hay más elementos en el resultado del Query
QueryResult.NotModifiable=No puede cambiar el ResultSet del Query
QueryResult.NotSupported=No apoyamos esta operación en el resultado de un Query
QueryResult.CloseError=Cerrar el resultado del Query da un error : {0}

#
# Query ResultExpressions
#
QueryResultExpressions.UnsupportedExpressionInResult=La expressión {0} no esta apoyada en resultados

#
# SQL
#
SQL.DeletePersistent.NotSupported=No apoyamos borración por Query de SQL/JPOXSQL.
SQL.StatementNullError=Tiene un Query de SQL que esta vacia. Es invalido
SQL.StatementNotSelectError=El estatement de SQL ("{0}") no empieza con SELECT. Es invalido
SQL.NoSelectionsError=El estatement de SQL ("{0}") no tiene ninguna columna en la selección. Es invalido.
SQL.CandidateExtentsInapplicableError=No se puede usar Extent de Candidatos con un Query de SQL.
SQL.CandidateCollectionsInapplicableError=No se puede usar collecciones de Candidato con un Query de SQL.
SQL.ResultInapplicableError=No se puede poner el resultado con un Query de SQL.
SQL.RangeInapplicableError=No se puede poner el serie con un Query de SQL.
SQL.FilterStringsInapplicableError=No se puede poner un filtro con un Query de SQL.
SQL.VariablesInapplicableError=No se puede usar variables con un Query de SQL.
SQL.GroupingNotExplicitError=SQL apoya grouping pero explicitamente como GROUP BY en el texto de SQL.
SQL.OrderingNotExplicitError=SQL apoya ordering pero explicitamente como ORDER BY en el texto de SQL.
SQL.Statement.Summary=Query de SQL : "{0}"

SQL.Candidate.IdColumnNotSelected=Query de SQL ("{0}") tiene una clase de candidato "{1}" pero no esta seleccionada la columna de identidad ("{2}"). Usted tiene que seleccionar la columna de identidad.
SQL.Candidate.DiscriminatorColumnNotSelected=Query de SQL tiene una clase de candidato "{0}" pero noa esta seleccionada la columna de discriminación "{1}". Usted tiene que seleccionar la columna de discriminación
SQL.Candidate.VersionColumnNotSelected=Query de SQL tiene una clase de candidato "{0}" pero no esta seleccionada la columna de versión "{1}". Usted tiene que seleccionar la columna de versión.

SQL.ParametersInapplicableError=No se puede usar parametros con un Query de SQL.
SQL.NoCandidateClassError=No hay clase de candidato con el Query de SQL
SQL.InvalidCandidateClassExtentError=La clase de candidato "{0}" esta incorecta para SQL. No puede tener un Extent (usa requires-extent="false" en el MetaData).
SQL.InvalidCandidateClassNondurableError=La clase de candidato "{0}" esta incorecta para SQL. Tiene que usar identidad de non-durable (usa identity-type="nondurable" en el MetaData).
SQL.IncorrectNumberOfParametersError=El Query de SQL hace falta {0} parametros, pero hay {1} solamente.
SQL.NoSuchFieldInResultClassError=La clase de resultado {0} del Query de SQL no tiene campo {1}
SQL.ResultClassesHaveNoTableError=El Query de SQL tiene un macro invalido - clases resultadas no tienen tablas {0}
SQL.ResultSetMissingColumnsError=El Query de SQL falta columnas ("{0}") del ResultSet
SQL.ParameterNotProvidedError=El Query de SQL hace falta el parametro {0}, pero no esta.
SQL.UndeclaredParameterError=El Query de JPOXSQL hace falta el parametro {0}, pero no esta.
SQL.ExecutionError=Error con la ejecucion de Query de SQL "{0}".
SQL.ImportInapplicableError=No se puede usarlos imports con un Query de SQL.
SQL.ResultExtractionError=Error con la extracción de resultados por el Query de SQL "{0}"
SQL.ExecuteWithMapParamMinimumError=Usar executeWithMap para Query de SQL debe tener las claves empezando a 1. Este mapa empieza a {0}!!
SQL.ExecuteWithMapParamTypeError=Usar executeWithMap para Query de SQL debe tener todas las claves de tipo Integer. Este mapa contiene unos de tipo "{0}"

SQL.ParametersRequiredButNoneSupplied=SQL query "{0}" necesita {1} parametros pero no hay ninguno
SQL.ParameterAtPositionNotSupplied=SQL query "{0}" necesita un parametro para la posición {1} pero no hay uno en el Map.

#
# JPOX SQL
#
JPOXSQL.InvalidCandidateClassExtentError=La clase de candidato "{0}" esta incorecta para JPOXSQL. No puede tener un Extent (usa requires-extent="false" en el MetaData).
JPOXSQL.InvalidCandidateClassNondurableError=La clase de candidato "{0}" esta incorecta para JPOXSQL. Tiene que usar identidad de non-durable (usa identity-type="nondurable" en el MetaData).
JPOXSQL.IncorrectNumberOfParametersError=El Query de JPOXSQL hace falta {0} parametros, pero hay {1} solamente.
JPOXSQL.NoSuchFieldInResultClassError=La clase de resultado {0} del Query de JPOXSQL no tiene campo {1}
JPOXSQL.ResultClassesHaveNoTableError=El Query de JPOXSQL tiene un macro invalido - clases resultadas no tienen tablas {0}
JPOXSQL.ResultSetMissingColumnsError=El Query de JPOXSQL falta columnas ("{0}") del ResultSet
JPOXSQL.ParameterNotProvidedError=El Query de JPOXSQL hace falta el parametro {0}, pero no esta.
JPOXSQL.UndeclaredParameterError=El Query de JPOXSQL tiene una parametro {0} en el SQL, pero no hay una declaración.
JPOXSQL.ExecutionError=Error con la ejecucion de Query de JPOXSQL "{0}".

#
# Query Statement
#
RDBMS.QueryStatement.OracleBooleanExpression=OracleAdapter solamente apoya las expresiones de boolean char