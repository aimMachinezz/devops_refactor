################################################################################
# Copyright (c) 2003 Andy Jefferson and others. All rights reserved.
# This program and the accompanying materials are made available under
# the terms of the JPOX License v1.0 which accompanies this distribution.
#
# Resources for org.jpox package (Spanish)
# Version : $Revision: 1.86.2.2 $
################################################################################
#
# ClassLoader
#
ClassLoader.ClassNotFound=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH.

#
# ClassLoaderResolver
#
ClassLoaderResolver.PluginNotFound=PersistenceManagerFactory tiene ClassLoaderResolver de nombre "{0}" pero el mecanismo de plugin de JPOX no lo ha encontrado. Por favor compruebe el CLASSPATH y especificación de plugin.
ClassLoaderResolver.PluginClassNotFound=ClassLoaderResolver plugin con clase "{0}" pero no existe! Por favor compruebe el CLASSPATH y especificación de plugin.
ClassLoaderResolver.Error=ClassLoaderResolver para la clase "{0}" ha dado error en la creación : {1}

ClassLoaderResolver.ClassNotFound=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH. ClassResolver llamado por {1} (linea {2})
ClassLoaderResolver.ClassNotFoundSimple=¡La clase {0} no esta en el CLASSPATH!. Por favor compruebe la especificación y el CLASSPATH.

#
# DataSource
#
DataSource.DatabaseDriverNotFound=La clase del driver para su base de datos ("{0}") no se encuentra en el CLASSPATH. Por favor, compruebe que el CLASSPATH es correcto, y que también lo es el nombre de la clase del driver JDBC.
DataSource.ConnectionPoolLibraryNotFound=Usted quiere usar una pool de conexiones de "{0}" pero no se encuentra una de las librerias ({1}).
DataSource.ConnectionPoolError=Ocurrió un error durante la creación de la pool de conexiones "{0}" para el driver JDBC "{1}" y la URL "{2}" : {3}
DataSource.ConnectionPoolPluginNotFound=El plugin de pool de conexiones de "{0}" no está en el CLASSPATH
DataSource.ConnectionPoolPluginError=Ocurrió un error al intentar usar el plugin "{0}" por crear una pool de conexiones: {1}
DataSource.ConnectionPoolConfigurationFileError=Ocurrío un error intentando de leer el archivo de configuración de una pool de conexiones : {0}

#
# Cache
#
Cache.Level1.PluginNotFound=Cache de nivel 1 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
Cache.Level1.PluginClassNotFound=Cache de nivel 1 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
Cache.Level1.Initialised=Cache de nivel 1 del tipo "{0}" inicializada

Cache.Level1.AddingObject=Añadiendo a la Cache de nivel 1 el objeto con id "{0}"
Cache.Level1.AddingNullObjectError=Intenta añadir a la Cache de nivel 1 un objeto con id nulo. Rechazado.
Cache.Level1.RetrievalFailed=Objeto con id "{0}" no esta en la Cache de nivel 1 [tamaño = {1}]
Cache.Level1.RetrievalOfObjectLevel1=Objeto con id "{0}" usado de la Cache nivel 1 [tamaño = {1}]
Cache.Level1.RemovingObject=Borrando de la Cache de nivel 1 el objeto con id "{0}" [tamaño = {1}]
Cache.Level1.RemovalOfObjectFailed=El borrado de la Cache del objeto con id "{0}" falló. No existia en la Cache de nivel 1.
Cache.Level1.Cleared=Cache de nivel 1 vaciada.


Cache.Level2.PluginNotFound=Cache de nivel 2 "{0}" no esta registrado. Por favor compruebe el CLASSPATH y la especificación de plugin.
Cache.Level2.PluginClassNotFound=Cache de nivel 2 "{0}" esta registrado para usar la clase "{1}" pero no existe. Por favor compruebe el CLASSPATH y la especificación de plugin.
Cache.Level2.Initialised=Cache de nivel 2 del tipo "{0}" inicializada

Cache.Level2.AddingObject=Añadiendo a la Cache de nivel 2 el objeto con id "{0}"
Cache.Level2.AddingNullObjectError=Intenta añadir a la Cache de nivel 2 un objeto con id nulo. Rechazado.
Cache.Level2.RetrievalFailed=Objeto con id "{0}" no esta en la Cache de nivel 2 [tamaño = {1}]
Cache.Level2.RetrievalOfObjectLevel1=Objeto con id "{0}" usado de la Cache nivel 2 [tamaño = {1}]
Cache.Level2.RemovingObject=Borrando de la Cache de nivel 2 el objeto con id "{0}" [tamaño = {1}]
Cache.Level2.RemovalOfObjectFailed=El borrado de la Cache del objeto con id "{0}" falló. No existia en la Cache de nivel 2.
Cache.Level2.Cleared=Cache de nivel 2 vaciada.


Cache.CantStoreNullObject=Intenta almacenar un valor nulo en la Cache. No es posible.
Cache.ObjectConnectedError=No se puede añadir el objeto "{0}" a la Cache de nivel 2 porque esta conectado a un PersistenceManager.

#
# FetchPlan
#
FetchPlan.FetchGroupFieldNotFound=El campo "{0}" del fetch-group "{1}" no existe en la clase "{2}
FetchPlan.NestedFetchGroupNotFound=Fetch-group "{0}" jerarquizado en el fetch-group "{1}" no existe en la clase "{2}"
FetchPlan.MaxFetchDepthInvalid=El valor {0} no tiene ningun sentido para maxFetchDepth. Usted tiene que poner -1 (no hay limite) o un valor positivo.
FetchPlan.DetachmentRootsNotChangeableBeforeCommit=No se puede cambiar los raices de detachar antes de commit().

#
# PersistenceManager
#
PM.Opened=Persistence Manager "{0}" se abrió para el datastore "{1}"
PM.Closed=Persistence Manager "{0}" se cerró
PM.IsClosed=Persistence Manager ya esta cerrado

PM.MakePersistent=Haciendo el objeto persistente : "{0}"
PM.MakePersistentAttach=Haciendo el objeto persistente (adjuntar) : "{0}"
PM.DeletePersistent=Borrando el objeto de persistencia : "{0}"
PM.MakeTransient=Haciendo el objeto transitorio : "{0}"
PM.Detach=Haciendo el objeto detachado : "{0}" (profundidad={1})
PM.DetachCopy=Detachando una copia del objeto : "{0}" (profundidad={1})

PM.DetachOnCloseStart=DetachOnClose : Cerrando PM asi haciendo detach con todos los objetos corrientes ...
PM.DetachOnCloseEnd=DetachOnClose : detach terminado

PM.PersistenceByReachability.RunningCommitCheck=Haciendo la comprobación de "persistence-by-reachability" (commit) ...
PM.PersistenceByReachability.ObjectNoLongerReachable=El objeto con identidad "{0}" se almacenó con una llamada a makePersistent() pero ya no esta accesible. Vamos a borrar el objeto de la base de datos.
PM.PersistenceByReachability.CompletedCommitCheck=Ha terminado la comprobación de "persistence-by-reachability" (commit).

PM.DifferentOwner=Objeto con id "{0}" es manejado por otro Persistence Manager
PM.EvictError=No fué posible desahuciar algunos de los objetos
PM.RefreshError=No fué posible refrescar algunos de los objetos
PM.RetrieveError=No fué posible recuperar algunos de los objetos
PM.MakePersistentError=No fué posible hacer persistente algunos de los objetos
PM.DeletePersistentError=No fué posible borrar algunos de los objetos
PM.DeletePersistentOnTransientInstances=No fué posible borrar objetos transitorios.
PM.DeletePersistentOnTransactionalInstances=No fué posible borrar objetos transitorios transaccional. Identidad de objeto = {0}
PM.MakeTransientError=No fué posible hacer transitorio algunos de los objetos
PM.MakeTransactionalError=No fué posible hacer transaccional algunos de los objetos
PM.MakeNonTransactionalError=No fué posible hacer non-transaccional algunos de los objetos
PM.MakeNonTransactionalOnTransientDirtyInstances=No fué posible cambiar el estado de objetos entre sucio transitorio y non-transaccional
PM.MakeNontransactionalOnNontransactionalTransientInstances=No fué posible cambiar el estado de objetos entre transitorio y non-transaccional
PM.DetachError=Era imposible detachar algunos objetos. Por favor compruebe las excepciones adjuntados a esta excepcion para los detalles.
PM.Detach.TransientOutsideTransaction=No se puede usar detachCopy() fuera de una transacción cuando haya instancias en el estado "transient" alcanzable

PM.NonTransactionalOperationInvalid=Usted ha invocado el metodo del PersistenceManager "{0}" pero no hay ninguna transacción activa y nontransactionalRead no esta puesto. Es invalido.

PM.NewObjectIdInstance.ConstructionError=Ocurrió un error durante la construcción de una instancia de Id de tipo "{0}" por la clase abstracta "{1}"

PM.MultithreadUnsupported=El modo Multithreaded no está soportado
PM.IgnoreCacheUnsupported=El modo Ignore Cache no está soportado

PM.ObjectNotDetached=Objeto no es detachado. Esta operación le hace falta un objeto en este estado
PM.ObjectNotPersistent=Objeto es transitorio
PM.ObjectNotTransactional=Objeto no es transaccional : {0}
PM.ObjectAlreadyTransactional=Objeto ya es transaccional : {0}

PM.ObjectDoesntExist=Objeto no existe
PM.GetObjectByIdNullId=getObjectById() no accepta valores nulos
PM.GetObjectsByIdNullId=getObjectsById() no accepta valores nulos
PM.GetObjectByIdClassNotFound=El objeto con id "{0}" no ha sido encontrado

PM.GetPersistenceManagerFactoryNotImplemented=¡getPersistenceManagerFactory no esta implementado en la clase al base!

PM.Query.NamedQueryNotFound=¡Query "{0}" de la clase "{1}" no existe!
PM.Query.LanguageNotSupportedByStore=El lenguaje de Query "{0}" no se corresponde con el del datastore.
PM.Query.InvalidArgumentType=Argumento del Query {0} : debe ser un objeto del tipo {1}
PM.Query.NamedQueryJDOQLOnlySingleString=Named Query "{0}" esta en MetaData con el atributo "unique" o "result-class". ¡Son solamente para usar con un Query de SQL o JPOXSQL!
PM.Query.NamedQueryResultClassNotFound=Named Query "{0}" tiene clase de resultado "{1}" pero no existe!

PM.ObjectIdClassNotFound=La clase de objectid "{0}" no está en el CLASSPATH. Por favor, comprueba el nombre de la clase y el CLASSPATH e inténtelo otra vez.
PM.HandleInvalid=Intenta obtener el PersistenceManager de un objeto que tiene {0} PersistenceManager(s)!

PM.ObjectId.ClassIsNull=No fué posible crear una identidad de objeto por una clase que es nulo!
PM.ObjectId.ClassHasNoMetaData=No fué posible crear una identidad de objeto para la clase "{0}" porque no tiene MetaData
PM.ObjectId.KeyValueNotSupported=No fué posible crear una identidad de objeto por la clase "{0}" porque el tipo de clave no esta soportada ({1})

PM.OptimisticVerificationError=Algunos objetos han fallado de commit() debido a problemas de verificación optimista.

#
# PersistenceManagerFactory
#
PMF.PropertyFileLoadError=No se puede leer el archivo de propiedades "{0}"
PMF.PropertyFileAlreadyLoaded=El archivo de propiedades "{0}" leemos antes. Vamos a ignorar el archivo de propiedades "{1}"

PMF.DeprecatedPropertyReplaced=Propiedad {0} ya no esta soportada. Usted debe usar {1}
PMF.UnknownProperty=Propiedad {0} desconocida - vamos a ignorarla
PMF.Version=PersistenceManagerFactory - Vendor: {0}  Versión: {1}
PMF.Initialised=PersistenceManagerFactory inicializado para la base de datos URL={0} driver={1} userName={2}
PMF.TransactionIsolationInvalid=La propiedad de aislamiento de transacciones no es válida : {0}={1}
PMF.NotConfigurableAfterGeneration=Cambios en la configuración no son posible despues de generar un PersistenceManager
PMF.CloseError=No es posible cerrar el PersistenceManagerFactory porque aún hay transacciones activas
PMF.PMFIsClosed=No se puede acceder o usar una PersistenceManagerFactory después de que ha sido cerrada.

PMF.JDO2Inaccessible=Las funcionalidades de JDO 2.0 no están disponibles! Por favor, compruebe que no hay un jar de JDO 1.0 antes de las clases de JDO 2.0 en su CLASSPATH.
PMF.PropertyUnusableForSchema=La propiedad {0} ha sido especificada pero no podemos usarla porque la base de datos es de sólo-lectura
PMF.PropertyValueInvalid=La propiedad "{0}" tiene el valor "{1}" pero el valor no es válido. Por favor consulte la documentacion para ver la lista de valores correctos.

PMF.ImplementationCreatorNotFound=El "implementation creator" de JPOX "{0}" no existe en el CLASSPATH. Para utilizar PersistenceManager.newInstance() usted tiene que poner JPOX Enhancer en el CLASSPATH.
PMF.ImplementationCreatorNotConfigured=Implementation creator not configured. Due to that, the persistence of interfaces was disabled!
PMF.ImplementationCreatorInUse=The Implementation creator {0} is ready for use.

PMF.ApiAdapterNotFound=No hay ningun adaptador de API "{0}". Usando lo que tenemos ahora mismo

#
# DataSource driver
#
Driver.InvalidClass=La clase de driver JDBC no es válida "{0}" : quizás no haya puesto el JAR en el CLASSPATH, o el nombre de clase es incorrecto.

#
# SchemaManager
#
SchemaManager.Unavailable=No hay un SchemaManager disponible : {0}

#
# SchemaTool
#
SchemaTool.Title.SchemaCreation=JPOX SchemaTool (version {0}) : Creación del esquema
SchemaTool.Title.SchemaDeletion=JPOX SchemaTool (version {0}) : Eliminación del esquema
SchemaTool.Title.SchemaValidation=JPOX SchemaTool (version {0}) : Validación del esquema
SchemaTool.Title.DBInfo=JPOX SchemaTool (version {0}) : Información de la base de datos
SchemaTool.Title.SchemaInfo=JPOX SchemaTool (version {0}) : Schema information
SchemaTool.Classpath=JPOX SchemaTool : Classpath
SchemaTool.Classpath.Entry=>>  {0}
SchemaTool.InputJdoFiles=JPOX SchemaTool : Ficheros
SchemaTool.Properties=JPOX SchemaTool : Propiedades del sistema
SchemaTool.DatabaseTypeInfo=JPOX SchemaTool : Información de tipos de la base de datos
SchemaTool.DatabaseKeywords=JPOX SchemaTool : Palabras claves de la base de datos
SchemaTool.PropertyFile=JPOX SchemaTool : Usando las propiedades del archivo "{0}"
SchemaTool.PropertyFileInvalid=JPOX SchemaTool : Fichero de propiedades "{0}" no existe!

SchemaTool.HelpTitle=JPOX SchemaTool : Ayuda
SchemaTool.HelpCommand=>> org.jpox.SchemaTool [opciones] [archivos-JDO] [archivos-clase]
SchemaTool.HelpOptions=    donde las opciones son
SchemaTool.HelpOption.Create=    -create : Crea las tablas de datos por las clases de los archivos-JDO/clase
SchemaTool.HelpOption.Delete=    -delete : Borra las tablas de datos por las clases de los archivos-JDO/clase
SchemaTool.HelpOption.Validate=    -validate : Valida las tablas de datos por las clases de los archivos-JDO/clase
SchemaTool.HelpOption.DBInfo=    -dbinfo : Display the database info (Database version, supported options, jdbc types, etc)
SchemaTool.HelpOption.SchemaInfo=    -schemainfo : Display the schema info (DDL statements)
SchemaTool.HelpOption.DumpDdl=    -dumpDdl <filename> : write all DDL SQL statements to the given file instead of sending them to the DB
SchemaTool.HelpOption.Help=    -help : Escribir este mensaje
SchemaTool.HelpJDOFiles=    Los "archivos-JDO" (y clases) deben estar presentes en el CLASSPATH
SchemaTool.HelpJDOFiles=    Los "archivos-clase" deben estar presentes en el CLASSPATH

SchemaTool.ModeInvalid=JPOX SchemaTool : Parametro "mode" solo accepta valores de "create", "delete", "validate", "dbinfo", "schemainfo"

SchemaTool.Error=SchemaTool ha lanzado una excepción. Por favor consulte el Log para ver más detalles: {0}
SchemaTool.MetaDataParseError=Ocurrió un error al analizar los archivos-JDO !
SchemaTool.NoClassesError=No hay clases !
SchemaTool.ClassNotFoundError=No se encuentra la clase {0}! Por favor, compruebe que la clase existe en el CLASSPATH.
SchemaTool.DatabaseDriverNotSpecifiedError=No se encuentra el driver de base de datos!
SchemaTool.NoMetaDataFilesError=Error : No hay archivos XML de metainformación JDO !
SchemaTool.Success=SchemaTool ha terminado con exito
SchemaTool.OutputDDL=Poniendo el DDL del esquema a "{0}"

#
# Transactions
#
Transaction.StartedForConnection=Transacción empezada para la connection {0}
Transaction.FailedToStart=La ransacción no se pudo comenzar
Transaction.CommitForConnection=Haciendo commit de la transacción para la connexión {0}
Transaction.FailedToCommit=No se puedo hacer commit de la transacción
Transaction.RollbackForConnection=Haciendo rollback de transacción para la connexión {0}
Transaction.FailedToRollback=Transaccion ha fallado de restaurar
Transaction.NontransactionalWriteUnsupported=El modo Non-transaccional Write no está soportado
Transaction.OptimisticUnsupported=El modo Optimistic no está soportado
Transaction.IsolationLevelInvalid=Nivel de aislamiento no es válido : {0}

Transaction.Pessimistic.ConnectionRetrieved=La connexión {0} empezó para una transacción pesimista
Transaction.Pessimistic.ConnectionClosed=La connexión {0} terminó para una transacción pesimistac
Transaction.Optimistic.ConnectionRetrieved=La connexión {0} empezó para una transacción optimista
Transaction.Optimistic.ConnectionClosed=La connexión {0} terminó para una transacción optimista

Transaction.ObjectEnlistedInCache="{0}" : poniéndolo en la cache transactional
Transaction.ObjectEvictedFromCache="{0}" : quitándolo de la cache transactional

Transaction.CommitWithRollbackOnly=Transacción es "rollback-only", asi que no se puede hacer commit en este estado.

Transaction.ConnectionUnobtainable=No se pudo obtener una connexión.

#
# Types
#
Type.AddType=Soportando el tipo de Java {0} (default-persistent={1}, DFG={2}, default-embedded={3})

#
# Sequence
#
Sequence.SequenceNotFound=No hemos encontrado la secuencia "{0}". Por favor compruebe que existe en un archivo de Meta-Data.
Sequence.FactoryClassNotFound=No hemos encontrado el factory-class "{0}" por la secuencia "{1}". Está en el CLASSPATH ?
Sequence.FactoryClassInvocationError=Ocurrió un error durante la invocacion de metodo newInstance() en el factory-class "{0}" : {1}
Sequence.Allocated=La secuencia "{0}" ya existe y usa el generador "{1}"
Sequence.NotAllocatedError=La secuencia "{0}" no tiene valores asignados. Por favor llame primero a "allocate(int)" para asignar los valores.
Sequence.NotNumericError=La secuencia "{0}" no genera valores numéricos. Por favor llame a "next()" para obtener el valor como un Objeto.
Sequence.POIDConnectionOpenError=Error durante el proceso obtener la conexión por la generación de POID : {0}
Sequence.POIDConnectionCloseError=Error durante el proceso cerrar la conexión por la generación de POID : {0}

#
# Exceptions
#
Exception.ClassNotPersistenceCapable=La clase "{0}" no es s epuede hacer persistente. Esto significa que no esta analizada, o que la version analizada no esta en el CLASSPATH (o antes se encuentra una version que no esta analizada), o que el Meta-Data de la clase no existe o no se encuentra disponible.
Exception.ClassHasNoMetaData=No hemos encontrado el Meta-Data para la clase "{0}". Por favor compruebe que lo ha puesto en un archivo XML para JDO correcto y válido.
Exception.ClassNotDetachable=La clase "{0}" no es Detachable. Este significa que el MetaData de la clase no incluyo el atributo "detachable" como "true".
Exception.ClassesNotDetachable=Algunos de los objetos no son de clases que son Detachable. Este significa que el MetaData de las clases no incluyo el atributo "detachable" como "true". Las excepciones adjuntas tienen los detalles de los objetos.
Exception.ObjectDetached=El objeto de tipo "{0}" esta detachado. ¡No se puede utilizar objetos detachados con esta operación!

Exception.UnsupportedConnectionFactory=La factoría de conexiones ({0}) no está soportada - debe ser un javax.sql.DataSource
Exception.CommitStateTransition=Una transacción de base de datos ha sido acometida, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO

Exception.ConnectionFactoryNotFound=La factoría de connecciones "{0}" no existe o no se encuentra disponible
Exception.ConnectionInUse=Ya existe una conexión a la base de datos - quizas un Query siga ? La especificacion de JDO sección 12.6 dice que un PersistenceManager puede usar solamente una connección a la base de datos en un momento. Si usted quiere hacer otras operaciones, debe usar más PersistenceManagers.

Exception.RollbackStateTransition=Una transacción de la base de datos ha sido restaurada, pero se lanzaron las siguientes excepciones durante la transición del estado de los objetos de JDO
Exception.TransactionActive=La transacción está activo todavia. Debe cerrar las transacciones usando los métodos commit() o rollback().
Exception.TransactionNotActive=La transacción no está activo. Tiene que poner este en una transacción o usar su PersistenceManagerFactory con 'NontransactionalRead' como 'true'
Exception.TransactionCommiting=Se está haciendo commit o rollback de la transacción. Esta operación no esta disponible en este momento.

Exception.IncompatibleQueryElementType=Tipo de parámetro incompatible : era {0}, pero debe ser {1} o una subclase
Exception.IncorrectNumberOfInstancesReturnedFromQuery=El Query de JDOQL ha vuelto más que una instancia pero "unica" esta "verdad" o hay solo aggregados asi que debe devolver una como maxima.

Exception.NoColumn=El campo no tiene una columna en el base de datos : {0}
Exception.NoExtent=La clase persistente no tiene un Extent (definido en el Meta-Data) : {0}
Exception.NoSuchPersistentField=El campo "{0}" no existe en {1} o no es persistente
Exception.NoSuchPersistentFieldNo=El campo #{0} no existe en {1} o no es persistente

Exception.NoTableManaged=La clase "{0}" no tiene una tabla en la base de datos, pero esta operacion la necesita. Por favor compruebe el MetaData

Exception.TableMismatch={0} no puede ser referenciado en una expression de tabla basado en {1} porque no existe ninguna unión a su tabla, {2}

#
# User Types
#
Types.User.FileNonExistent=¡Los tipos del usuario deben estar en el archivo "{0}", pero el archivo no existe!
Types.User.ErrorReadingFile=Los tipos del usuario deben estar en el archivo "{0}" pero ocurrió un error al leerlo : {1}
Types.User.MappingNotFound=La clase de mapping "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
Types.User.SCOWrapperNotFound=La clase de SCO "wrapper" "{0}" no existe o no es encuentra. Por favor, compruebe la especificación de la clase y el CLASSPATH. La clase tiene que estar en el CLASSPATH.
Types.User.ResolveEntity=resolveEntity({0}, {1})
Types.User.FileNotInClassPath=¡Los tipos del usuario deben estar en el archivo "{0}" pero no es encuentra en el classpath.

#
# Primary Key
#
PrimaryKey.NotPublicError=La clase {0} ha sido definido con el object-id class {1} que no es publico. El ObjectId class debe ser publico.
PrimaryKey.InnerNotStaticError=La clase {0} ha sido definido con el object-id class {1} que es "inner" pero no es estatica. El ObjectId class debe ser estatica si es "inner".
PrimaryKey.NotSerializableError=La clase {0} ha sido definido con el object-id class {1} que no es Serializable. El ObjectId class debe ser Serializable.
PrimaryKey.DefaultConstructorError=La clase {0} ha sido definido con el object-id class {1} que no tiene constructor defecto. Todos los objectId classes deben tener un constructor defecto.
PrimaryKey.StringConstructorError=La clase {0} ha sido definido con el object-id class {1} que no tiene un constructor de String. Todos los objectId classes deben tener un constructor de String.
PrimaryKey.ToStringError=La clase {0} ha sido definido con el object-id class {1} que no define el metodo toString(). Todos los objectId classes deben definir el metodo toString().
PrimaryKey.FieldNotSerializableError=La clase {0} ha sido definido con el object-id class {1} que tiene el campo {2} que no es Serializable. Todos los campos non-estaticos del objectId class deben ser Serializable.
PrimaryKey.FieldNotPublicError=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2} que no es publico. Todos los campos non-estaticos de un objectId class deben ser publico.
PrimaryKey.FieldPersistenceCapableError=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} que es persistence-capable. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
PrimaryKey.FieldShouldReferObjectIdClass=La clase {0} ha sido definido con el object-id class {1} que tiene un campo {2}. El campo {0}.{2} tiene un tipo {3} pero debe ser {4}. Todos los campos non-estaticos de un objectId class no deben ser persistence-capable.
PrimaryKey.InnerClassNotStaticError=La clase {0} ha sido definido con el object-id class {1} que es clase interior pero no es estatico. Todos los objectId classes que son clases interiores deben ser estatico.
PrimaryKey.SingleFieldIdMultipleFieldsError=La clase {0} ha sido definido con el JDO SingleFieldIdentity object-id class, pero hay más que un campo de primary key definido por la clase. Debe ser solamente un campo como primary'key.
PrimaryKey.IncorrectNumberOfPKFieldsError=La clase {0} ha sido definido con el object-id class {1} que tiene {2} campos, mientras la clase ha sido definido con {3} campos en el "primary-key". El numero de campos en el objectidClass y el numero en el "primary-key" deben ser lo mismo.
PrimaryKey.InvalidPrimaryKey=Invalid primary key class {0}.

#
# Api Adapter
#
Api.Adapter.InstantiationError=Error : Un error ocurrio cuando creando un adaptador "{0}" : {1}

#
# CallbackHandler
#
CallbackHandler.InstantiationError=Error : Un error ocurrio cuando creando un CallbackHandler "{0}" : {1}

#
# Plugin
#
Plugin.FileNonExistent=File {0} doesn't exist. Check your path or classpath.
Plugin.ErrorReadingFile=Error reading plug-in file {0} : {1}
Plugin.ExtensionPointNotRegistered=Extension Point "{0}" not registered, but plugin "{1}" defined in {2} refers to it.
Plugin.LoadingExtensionPoints=Loading extension points from plug-in file {0}.
Plugin.LoadingExtensions=Loading extensions from plug-in file {0}.
Plugin.RegistryNotFound=Plugin Registry "{0}" no existe. Usando registry de JPOX
Plugin.RegistryNotFoundWithReason=Plugin Registry "{0}" no existe. Usando registry de JPOX. Reason : {1}.

#
# SCO
#
Exception.IncompatibleType=El tipo de parámetro solicitado {0} es incompatible parameter : era {1} pero debe ser {2}
Exception.NullsNotAllowed=El campo {0} no puede ser nulo
Exception.UnownedSCOException=La collección no es preguntable como no tiene dueño que es un objeto de primera clase

SCO.Collection.PassThrough=El campo "{0}" de la clase "{1}" es una collección o una mapa de SCO : todos las llamas van a la base de datos
SCO.Collection.Cached=El campo "{0}" de la clase "{1}" es una collección o una mapa de SCO : usa un Cache (lazy-loading={2})

SCO.NewInstance.FieldTypeInvalid={0} no es un tipo valido de SCO por campo {1}, deb ser compatible con {2}
SCO.NewInstance.ClassInvalid=La clase {0} no es apoyado como objeto de clase segundo (SCO)

SCO.Comparator.ClassNotFound=El campo "{0}" debe usar un comparator de clase "{1}" pero esa clase no existe en el CLASSPATH. Por favor compruebe el nombre de la clase de comparator.

SCO.ErrorExecutingMethod=Execución del metodo "{0}" en el campo "{1}" ha causado un error : {2}

#
# StateManager
#
StateManager.SecurityProblem=No hay bastante acceso a org.jpox.*
StateManager.DisconnectClone=Desconectando del clono {0} de {1}
StateManager.InvalidFieldForClass=El campo {0} de la clase {1} no existe
StateManager.StateManagerChangeError=Cambiar el StateManager da un error
StateManager.StateManagerDisconnectError=Desconectar el StateManager da un error
StateManager.ClearingStateManager=Vaciando el StateManager de {0}
StateManager.MethodNotSupported=El metodo no es apoyado
StateManager.SecondClassObjectShareError=No es posible compartir SCO's con dueños; objeto doñado por campo {0} del objeto {1}
StateManager.DeleteRecursiveError=Recurrente llamada a deletePersistent()
StateManager.FlushRecursiveError=Recurrente llamada a flush()
StateManager.InconsistentDirtyStateError=Objeto tiene el estado ´sucio´´ pero ¡no hay campos sucios!
StateManager.Disconnect=Disconectando {0} de {1}
StateManager.NotPersistableClassError=No puede persistir la clase {0}
StateManager.ObjectDoesntExist=Objeto no existe
StateManager.GetObjectByIdClassNotFound=La clase "{0}" del objeto con id "{0}" na ha sido encontrado
StateManager.ClassNotFoundError=La clase {0} no esta ! Por favor, comprueba usted que la clase existe en el CLASSPATH.
StateManager.PrimaryKeyFieldIsNull=The primary-key field {0} is null.
StateManager.SingleFieldIdentityPKFieldIsNull=Un objeto de la clase "{0}" usa SingleFieldIdentity con el campo "{1}" pero el campo no tiene ningun valor! Usted debe poner un valor, o usa "value-strategy" con este campo.

StateManager.ClassNotRegistered=La clase "{0}" no ha sido registrada. Por favor compruebe que esta analizada.
StateManager.ClassNotConstructable=No podemos crear una instancia de la clase "{0}". Si es "abstract", usted tiene que comprobar que no hay una fila por esa clase en la base de datos sin una fila en la tabla de una subclase.

StateManager.ValueStrategyInvalid=El campo "{0}" tiene value-strategy de "{1}" pero el tipo del campo no esta correcta usarlo.

StateManager.FieldRegisteredForUpdateAfterInsertion=El campo "{0}" del objeto "{1}" ha sido registrado para actualización cuando su valor PC esta en la base de datos.
StateManager.FieldBeingUpdatedNowValueInserted=Vamos a actualizar el valor del campo "{0}" del objeto "{1} como su valor PC ya esta en la base de datos.

StateManager.DetachOfDeletedObjectNotPossible=No podemos "detach" al objeto de tipo "{0}" y con identidad "{1}" porque ha sido borrado!
StateManager.DetachOfAlreadyDetachedObjectNotPossible=No podemos "detach" el objeto de tipo "{0}" y con identidad "{1}" porque ya es "detached"!
StateManager.DetachOfObjectFailed=El "detach" del objeto de tipo "{0}" y con identidad "{1}" ha fallado. Por favor, compruebe el Log para alguna detalle.

StateManager.DeleteDependentNulledField=Vamos a borrar el objeto "{0}" porque esta el valor en un campo ({1}) donde el valor has sido anulado y el campo es delete-dependent.

StateManager.IllegalStateTransition=Una transition ilegal "{0}" ha sido intentado desde el estado "{1}", sm = "{2}"

#
# LifeCycle states
#
LifeCycle.HollowReadFieldNotAllowedNotActiveTx=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.
LifeCycle.PersistentNontransactionalReadFieldNotAllowedNotActiveTx=No se puede leer los campos fuera de una transacción. Used debe pensar en poner 'NontransactionalRead=true'.

LifeCycle.PersistentNewDeletedToNontransactional=No es posible cambiar el estado del objeto a nontransaccional como es nuevo, borrado y no esta comitido
LifeCycle.PersistentNewDeletedToTransient=No es posible cambiar el estado del objeto a transitorio como es nuevo, borrado y no esta comitido
LifeCycle.PersistentNewDeletedToReadField=No es posible leer campos de un objeto borrado
LifeCycle.PersistentNewDeletedToWriteField=No es posible escribir campos de un objeto borrado

LifeCycle.PersistentDeletedToNontransactional=No es posible cambiar el estado del objeto a nontransaccional como esta borrado
LifeCycle.PersistentDeletedToTransient=No es posible cambiar el estado del objeto a transitorio como esta borrado
LifeCycle.PersistentDeletedToReadField=No es posible leer campos de un objeto borrado
LifeCycle.PersistentDeletedToWriteField=No es posible escribir campos de un objeto borrado

LifeCycle.PersistentDirtyToNontransactional=No es posible cambiar el estado del objeto a nontransaccional como es sucio
LifeCycle.PersistentDirtyToTransient=No es posible cambiar el estado del objeto a transitorio como es sucio

LifeCycle.PersistentNewToNontransactional=No es posible cambiar el estado del objeto a nontransaccional como no es nuevo y no esta comitido
LifeCycle.PersistentNewToTransient=No es posible cambiar el estado del objeto a transitorio como es nuevo y no esta comitido

LifeCycle.DetachedFieldNotCopied=El campo no esta copiado al objeto "detached". Usted tiene que añadirlo al FetchPlan y "detach" el objeto otra vez.

#
# Utils
#
XMLEntity.ResolveEntityLocal=XML Entity Public="{0}" System="{1}" : con source local "{2}"
XMLEntity.ResolveEntityRemote=XML Entity Public="{0}" System="{1}
XMLEntity.ResolveEntityNotFound=resolveEntity({0}, {1}) no existe
XMLEntity.ResolveEntityFailed=resolveEntity({0}, {1}) ha fallado!

SQLWarnings.ErrorObtainingWarningsFromConnection=Obtener las advertencias del Connection {0} da un error
SQLWarnings.ErrorObtainingWarningsFromStatement=Obtener las advertencias del Statement {0} da un error
SQLWarnings.ErrorObtainingWarningsFromResultSet=Obtener las advertencias del ResultSet {0} da un error

ReadWriteLock.WaitingForReadLock=Todavia espero el read lock por {0}
ReadWriteLock.AlreadyHoldsReadLock=Ya el Thread tiene un read lock
ReadWriteLock.WaitingForWriteLock=Todavia espero el write lock por {0}

Import.InvalidImportDeclaration=La declaración del import no es valido : {0}
Import.InvalidPackageImport=La declaración del package import no es valido : {0}
Import.DuplicateClassImport=La declaración del class import es duplicado : {0}
Import.ImportedClassNotFound=La clase de los imports no existe : {0}
Import.ClassNotFoundCached=Almacenando el hecho de que {0} no fuera encontrado por {1}
Import.ArrayTypesIllegal=Los tipos de Array son illegal : {0}
Import.AmbiguousClassDeclaration=Hay ambiguedad en la declaración de la clase ; puede ser {0} o {1}

Import.ClassNotImportedExplictly=La clase {0} no tenia un import por un Query - puede afectar el funcionamiento. Puede evitar esta situacion con un import explicito (import micarpeta.miclase).
Import.ClassResolved=La clase {0} ha sido resuelto a {1}

JDOFactory.Initialised=Factorias de datastore inicialisados
JDOFactory.AlreadyExists=Factoria ya existe. Devolviendo referencia
JDOFactory.DoesntExist=Factoria no existe. Creando una nueva
JDOFactory.FindingPersistenceManager=Buscando el PersistenceManagerFactory para el DataStore {0}

Macro.UnmatchedBraceError=Incomparable puntales para el macro de interrogacion: {0}
Macro.UnmatchedQuestionMarksError=Incomparable punto de interrogacion para el macro de parametro: {0}
Macro.CannotParseError=No puede parsar macro de identificacion: {0}

View.CircularDependencyError=Hay una dependencia circular entre las visiones

TypeConversion.BadTimestampFormat=El formato de Timestamp no esta mal: "{0}" - debe ser yyyy-mm-dd hh:mm:ss.fffffffff

NewInstance.ClassMissingConstructorError=Un constructor de la clase {0} no existe, parametros {1} 
NewInstance.ClassAccessError=Error cuando intentando usar la clase {0}
NewInstance.ClassInstantiationError=Error intentando crear un objeto de la clase {0}
NewInstance.ConstructorError=Excepcion tirado por constructor por {0}, {1}

#
# SingleFieldIdentity
#
SingleFieldIdentity.PcTypeNull=No era posible construir una identidad de SingleFieldIdentity de tipo "{0}" porque la clase dado es nulo
SingleFieldIdentity.IdTypeNull=El tipo de identidad para construir una identidad de SingleFieldIdentity para la clase "{0}" es nulo
SingleFieldIdentity.IdTypeInvalid=El tipo de identidad ("{0}") dado para construir una identidad de SingleFieldIdentity para la clase "{1}" no es valido.
SingleFieldIdentity.ValueNull=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" para la clase "{1}" es nulo.
SingleFieldIdentity.ValueTypeInvalid=El valor de llave dado para construir una identidad de SingleFieldIdentity de tipo "{0}" de la clase "{1}" es de un tipo invalido ("{2}") - debe ser "{3}".